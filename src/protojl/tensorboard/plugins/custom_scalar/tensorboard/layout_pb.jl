# Autogenerated using ProtoBuf.jl v1.0.11 on 2023-08-09T10:18:18.779
# original file: proto/tensorboard/plugins/custom_scalar/tensorboard/layout.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export MultilineChartContent, var"MarginChartContent.Series", MarginChartContent, Chart
export Category, Layout

struct MultilineChartContent
    tag::Vector{String}
end
PB.default_values(::Type{MultilineChartContent}) = (;tag = Vector{String}())
PB.field_numbers(::Type{MultilineChartContent}) = (;tag = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MultilineChartContent})
    tag = PB.BufferedVector{String}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, tag)
        else
            PB.skip(d, wire_type)
        end
    end
    return MultilineChartContent(tag[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MultilineChartContent)
    initpos = position(e.io)
    !isempty(x.tag) && PB.encode(e, 1, x.tag)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MultilineChartContent)
    encoded_size = 0
    !isempty(x.tag) && (encoded_size += PB._encoded_size(x.tag, 1))
    return encoded_size
end

struct var"MarginChartContent.Series"
    value::String
    lower::String
    upper::String
end
PB.default_values(::Type{var"MarginChartContent.Series"}) = (;value = "", lower = "", upper = "")
PB.field_numbers(::Type{var"MarginChartContent.Series"}) = (;value = 1, lower = 2, upper = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"MarginChartContent.Series"})
    value = ""
    lower = ""
    upper = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            value = PB.decode(d, String)
        elseif field_number == 2
            lower = PB.decode(d, String)
        elseif field_number == 3
            upper = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"MarginChartContent.Series"(value, lower, upper)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"MarginChartContent.Series")
    initpos = position(e.io)
    !isempty(x.value) && PB.encode(e, 1, x.value)
    !isempty(x.lower) && PB.encode(e, 2, x.lower)
    !isempty(x.upper) && PB.encode(e, 3, x.upper)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"MarginChartContent.Series")
    encoded_size = 0
    !isempty(x.value) && (encoded_size += PB._encoded_size(x.value, 1))
    !isempty(x.lower) && (encoded_size += PB._encoded_size(x.lower, 2))
    !isempty(x.upper) && (encoded_size += PB._encoded_size(x.upper, 3))
    return encoded_size
end

struct MarginChartContent
    series::Vector{var"MarginChartContent.Series"}
end
PB.default_values(::Type{MarginChartContent}) = (;series = Vector{var"MarginChartContent.Series"}())
PB.field_numbers(::Type{MarginChartContent}) = (;series = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MarginChartContent})
    series = PB.BufferedVector{var"MarginChartContent.Series"}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, series)
        else
            PB.skip(d, wire_type)
        end
    end
    return MarginChartContent(series[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MarginChartContent)
    initpos = position(e.io)
    !isempty(x.series) && PB.encode(e, 1, x.series)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MarginChartContent)
    encoded_size = 0
    !isempty(x.series) && (encoded_size += PB._encoded_size(x.series, 1))
    return encoded_size
end

struct Chart
    title::String
    content::Union{Nothing,OneOf{<:Union{MultilineChartContent,MarginChartContent}}}
end
PB.oneof_field_types(::Type{Chart}) = (;
    content = (;multiline=MultilineChartContent, margin=MarginChartContent),
)
PB.default_values(::Type{Chart}) = (;title = "", multiline = nothing, margin = nothing)
PB.field_numbers(::Type{Chart}) = (;title = 1, multiline = 2, margin = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Chart})
    title = ""
    content = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            title = PB.decode(d, String)
        elseif field_number == 2
            content = OneOf(:multiline, PB.decode(d, Ref{MultilineChartContent}))
        elseif field_number == 3
            content = OneOf(:margin, PB.decode(d, Ref{MarginChartContent}))
        else
            PB.skip(d, wire_type)
        end
    end
    return Chart(title, content)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Chart)
    initpos = position(e.io)
    !isempty(x.title) && PB.encode(e, 1, x.title)
    if isnothing(x.content);
    elseif x.content.name === :multiline
        PB.encode(e, 2, x.content[]::MultilineChartContent)
    elseif x.content.name === :margin
        PB.encode(e, 3, x.content[]::MarginChartContent)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Chart)
    encoded_size = 0
    !isempty(x.title) && (encoded_size += PB._encoded_size(x.title, 1))
    if isnothing(x.content);
    elseif x.content.name === :multiline
        encoded_size += PB._encoded_size(x.content[]::MultilineChartContent, 2)
    elseif x.content.name === :margin
        encoded_size += PB._encoded_size(x.content[]::MarginChartContent, 3)
    end
    return encoded_size
end

struct Category
    title::String
    chart::Vector{Chart}
    closed::Bool
end
PB.default_values(::Type{Category}) = (;title = "", chart = Vector{Chart}(), closed = false)
PB.field_numbers(::Type{Category}) = (;title = 1, chart = 2, closed = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Category})
    title = ""
    chart = PB.BufferedVector{Chart}()
    closed = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            title = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, chart)
        elseif field_number == 3
            closed = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return Category(title, chart[], closed)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Category)
    initpos = position(e.io)
    !isempty(x.title) && PB.encode(e, 1, x.title)
    !isempty(x.chart) && PB.encode(e, 2, x.chart)
    x.closed != false && PB.encode(e, 3, x.closed)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Category)
    encoded_size = 0
    !isempty(x.title) && (encoded_size += PB._encoded_size(x.title, 1))
    !isempty(x.chart) && (encoded_size += PB._encoded_size(x.chart, 2))
    x.closed != false && (encoded_size += PB._encoded_size(x.closed, 3))
    return encoded_size
end

struct Layout
    version::Int32
    category::Vector{Category}
end
PB.default_values(::Type{Layout}) = (;version = zero(Int32), category = Vector{Category}())
PB.field_numbers(::Type{Layout}) = (;version = 1, category = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Layout})
    version = zero(Int32)
    category = PB.BufferedVector{Category}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            version = PB.decode(d, Int32)
        elseif field_number == 2
            PB.decode!(d, category)
        else
            PB.skip(d, wire_type)
        end
    end
    return Layout(version, category[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Layout)
    initpos = position(e.io)
    x.version != zero(Int32) && PB.encode(e, 1, x.version)
    !isempty(x.category) && PB.encode(e, 2, x.category)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Layout)
    encoded_size = 0
    x.version != zero(Int32) && (encoded_size += PB._encoded_size(x.version, 1))
    !isempty(x.category) && (encoded_size += PB._encoded_size(x.category, 2))
    return encoded_size
end