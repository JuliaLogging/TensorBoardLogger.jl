# Autogenerated using ProtoBuf.jl v1.0.11 on 2023-06-19T18:18:25.010
# original file: /home/lior/TensorBoardLogger.jl/gen/proto/tensorboard/plugins/hparams/api.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export Interval, GetExperimentRequest, var"#DataType", Status, SortOrder, DatasetType
export MetricName, AggregationType, HParamInfo, ColParams, ListMetricEvalsRequest
export MetricInfo, MetricValue, ListSessionGroupsRequest, Experiment, Session, SessionGroup
export ListSessionGroupsResponse

struct Interval
    min_value::Float64
    max_value::Float64
end
PB.default_values(::Type{Interval}) = (;min_value = zero(Float64), max_value = zero(Float64))
PB.field_numbers(::Type{Interval}) = (;min_value = 1, max_value = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Interval})
    min_value = zero(Float64)
    max_value = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            min_value = PB.decode(d, Float64)
        elseif field_number == 2
            max_value = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return Interval(min_value, max_value)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Interval)
    initpos = position(e.io)
    x.min_value != zero(Float64) && PB.encode(e, 1, x.min_value)
    x.max_value != zero(Float64) && PB.encode(e, 2, x.max_value)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Interval)
    encoded_size = 0
    x.min_value != zero(Float64) && (encoded_size += PB._encoded_size(x.min_value, 1))
    x.max_value != zero(Float64) && (encoded_size += PB._encoded_size(x.max_value, 2))
    return encoded_size
end

struct GetExperimentRequest
    experiment_name::String
end
PB.default_values(::Type{GetExperimentRequest}) = (;experiment_name = "")
PB.field_numbers(::Type{GetExperimentRequest}) = (;experiment_name = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GetExperimentRequest})
    experiment_name = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            experiment_name = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return GetExperimentRequest(experiment_name)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GetExperimentRequest)
    initpos = position(e.io)
    !isempty(x.experiment_name) && PB.encode(e, 1, x.experiment_name)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GetExperimentRequest)
    encoded_size = 0
    !isempty(x.experiment_name) && (encoded_size += PB._encoded_size(x.experiment_name, 1))
    return encoded_size
end

@enumx var"#DataType" DATA_TYPE_UNSET=0 DATA_TYPE_STRING=1 DATA_TYPE_BOOL=2 DATA_TYPE_FLOAT64=3

@enumx Status STATUS_UNKNOWN=0 STATUS_SUCCESS=1 STATUS_FAILURE=2 STATUS_RUNNING=3

@enumx SortOrder ORDER_UNSPECIFIED=0 ORDER_ASC=1 ORDER_DESC=2

@enumx DatasetType DATASET_UNKNOWN=0 DATASET_TRAINING=1 DATASET_VALIDATION=2

struct MetricName
    group::String
    tag::String
end
PB.default_values(::Type{MetricName}) = (;group = "", tag = "")
PB.field_numbers(::Type{MetricName}) = (;group = 1, tag = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MetricName})
    group = ""
    tag = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            group = PB.decode(d, String)
        elseif field_number == 2
            tag = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return MetricName(group, tag)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MetricName)
    initpos = position(e.io)
    !isempty(x.group) && PB.encode(e, 1, x.group)
    !isempty(x.tag) && PB.encode(e, 2, x.tag)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MetricName)
    encoded_size = 0
    !isempty(x.group) && (encoded_size += PB._encoded_size(x.group, 1))
    !isempty(x.tag) && (encoded_size += PB._encoded_size(x.tag, 2))
    return encoded_size
end

@enumx AggregationType AGGREGATION_UNSET=0 AGGREGATION_AVG=1 AGGREGATION_MEDIAN=2 AGGREGATION_MIN=3 AGGREGATION_MAX=4

struct HParamInfo
    name::String
    display_name::String
    description::String
    var"#type"::var"#DataType".T
    domain::Union{Nothing,OneOf{<:Union{google.protobuf.ListValue,Interval}}}
end
PB.oneof_field_types(::Type{HParamInfo}) = (;
    domain = (;domain_discrete=google.protobuf.ListValue, domain_interval=Interval),
)
PB.default_values(::Type{HParamInfo}) = (;name = "", display_name = "", description = "", var"#type" = var"#DataType".DATA_TYPE_UNSET, domain_discrete = nothing, domain_interval = nothing)
PB.field_numbers(::Type{HParamInfo}) = (;name = 1, display_name = 2, description = 3, var"#type" = 4, domain_discrete = 5, domain_interval = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:HParamInfo})
    name = ""
    display_name = ""
    description = ""
    var"#type" = var"#DataType".DATA_TYPE_UNSET
    domain = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            display_name = PB.decode(d, String)
        elseif field_number == 3
            description = PB.decode(d, String)
        elseif field_number == 4
            var"#type" = PB.decode(d, var"#DataType".T)
        elseif field_number == 5
            domain = OneOf(:domain_discrete, PB.decode(d, Ref{google.protobuf.ListValue}))
        elseif field_number == 6
            domain = OneOf(:domain_interval, PB.decode(d, Ref{Interval}))
        else
            PB.skip(d, wire_type)
        end
    end
    return HParamInfo(name, display_name, description, var"#type", domain)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::HParamInfo)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.display_name) && PB.encode(e, 2, x.display_name)
    !isempty(x.description) && PB.encode(e, 3, x.description)
    x.var"#type" != var"#DataType".DATA_TYPE_UNSET && PB.encode(e, 4, x.var"#type")
    if isnothing(x.domain);
    elseif x.domain.name === :domain_discrete
        PB.encode(e, 5, x.domain[]::google.protobuf.ListValue)
    elseif x.domain.name === :domain_interval
        PB.encode(e, 6, x.domain[]::Interval)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::HParamInfo)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.display_name) && (encoded_size += PB._encoded_size(x.display_name, 2))
    !isempty(x.description) && (encoded_size += PB._encoded_size(x.description, 3))
    x.var"#type" != var"#DataType".DATA_TYPE_UNSET && (encoded_size += PB._encoded_size(x.var"#type", 4))
    if isnothing(x.domain);
    elseif x.domain.name === :domain_discrete
        encoded_size += PB._encoded_size(x.domain[]::google.protobuf.ListValue, 5)
    elseif x.domain.name === :domain_interval
        encoded_size += PB._encoded_size(x.domain[]::Interval, 6)
    end
    return encoded_size
end

struct ColParams
    name::Union{Nothing,OneOf{<:Union{MetricName,String}}}
    order::SortOrder.T
    missing_values_first::Bool
    filter::Union{Nothing,OneOf{<:Union{String,Interval,google.protobuf.ListValue}}}
    exclude_missing_values::Bool
end
PB.oneof_field_types(::Type{ColParams}) = (;
    name = (;metric=MetricName, hparam=String),
    filter = (;filter_regexp=String, filter_interval=Interval, filter_discrete=google.protobuf.ListValue),
)
PB.default_values(::Type{ColParams}) = (;metric = nothing, hparam = "", order = SortOrder.ORDER_UNSPECIFIED, missing_values_first = false, filter_regexp = "", filter_interval = nothing, filter_discrete = nothing, exclude_missing_values = false)
PB.field_numbers(::Type{ColParams}) = (;metric = 1, hparam = 2, order = 3, missing_values_first = 4, filter_regexp = 5, filter_interval = 6, filter_discrete = 7, exclude_missing_values = 8)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ColParams})
    name = nothing
    order = SortOrder.ORDER_UNSPECIFIED
    missing_values_first = false
    filter = nothing
    exclude_missing_values = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = OneOf(:metric, PB.decode(d, Ref{MetricName}))
        elseif field_number == 2
            name = OneOf(:hparam, PB.decode(d, String))
        elseif field_number == 3
            order = PB.decode(d, SortOrder.T)
        elseif field_number == 4
            missing_values_first = PB.decode(d, Bool)
        elseif field_number == 5
            filter = OneOf(:filter_regexp, PB.decode(d, String))
        elseif field_number == 6
            filter = OneOf(:filter_interval, PB.decode(d, Ref{Interval}))
        elseif field_number == 7
            filter = OneOf(:filter_discrete, PB.decode(d, Ref{google.protobuf.ListValue}))
        elseif field_number == 8
            exclude_missing_values = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return ColParams(name, order, missing_values_first, filter, exclude_missing_values)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ColParams)
    initpos = position(e.io)
    if isnothing(x.name);
    elseif x.name.name === :metric
        PB.encode(e, 1, x.name[]::MetricName)
    elseif x.name.name === :hparam
        PB.encode(e, 2, x.name[]::String)
    end
    x.order != SortOrder.ORDER_UNSPECIFIED && PB.encode(e, 3, x.order)
    x.missing_values_first != false && PB.encode(e, 4, x.missing_values_first)
    if isnothing(x.filter);
    elseif x.filter.name === :filter_regexp
        PB.encode(e, 5, x.filter[]::String)
    elseif x.filter.name === :filter_interval
        PB.encode(e, 6, x.filter[]::Interval)
    elseif x.filter.name === :filter_discrete
        PB.encode(e, 7, x.filter[]::google.protobuf.ListValue)
    end
    x.exclude_missing_values != false && PB.encode(e, 8, x.exclude_missing_values)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ColParams)
    encoded_size = 0
    if isnothing(x.name);
    elseif x.name.name === :metric
        encoded_size += PB._encoded_size(x.name[]::MetricName, 1)
    elseif x.name.name === :hparam
        encoded_size += PB._encoded_size(x.name[]::String, 2)
    end
    x.order != SortOrder.ORDER_UNSPECIFIED && (encoded_size += PB._encoded_size(x.order, 3))
    x.missing_values_first != false && (encoded_size += PB._encoded_size(x.missing_values_first, 4))
    if isnothing(x.filter);
    elseif x.filter.name === :filter_regexp
        encoded_size += PB._encoded_size(x.filter[]::String, 5)
    elseif x.filter.name === :filter_interval
        encoded_size += PB._encoded_size(x.filter[]::Interval, 6)
    elseif x.filter.name === :filter_discrete
        encoded_size += PB._encoded_size(x.filter[]::google.protobuf.ListValue, 7)
    end
    x.exclude_missing_values != false && (encoded_size += PB._encoded_size(x.exclude_missing_values, 8))
    return encoded_size
end

struct ListMetricEvalsRequest
    experiment_name::String
    session_name::String
    metric_name::Union{Nothing,MetricName}
end
PB.default_values(::Type{ListMetricEvalsRequest}) = (;experiment_name = "", session_name = "", metric_name = nothing)
PB.field_numbers(::Type{ListMetricEvalsRequest}) = (;experiment_name = 3, session_name = 1, metric_name = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ListMetricEvalsRequest})
    experiment_name = ""
    session_name = ""
    metric_name = Ref{Union{Nothing,MetricName}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 3
            experiment_name = PB.decode(d, String)
        elseif field_number == 1
            session_name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, metric_name)
        else
            PB.skip(d, wire_type)
        end
    end
    return ListMetricEvalsRequest(experiment_name, session_name, metric_name[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ListMetricEvalsRequest)
    initpos = position(e.io)
    !isempty(x.experiment_name) && PB.encode(e, 3, x.experiment_name)
    !isempty(x.session_name) && PB.encode(e, 1, x.session_name)
    !isnothing(x.metric_name) && PB.encode(e, 2, x.metric_name)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ListMetricEvalsRequest)
    encoded_size = 0
    !isempty(x.experiment_name) && (encoded_size += PB._encoded_size(x.experiment_name, 3))
    !isempty(x.session_name) && (encoded_size += PB._encoded_size(x.session_name, 1))
    !isnothing(x.metric_name) && (encoded_size += PB._encoded_size(x.metric_name, 2))
    return encoded_size
end

struct MetricInfo
    name::Union{Nothing,MetricName}
    display_name::String
    description::String
    dataset_type::DatasetType.T
end
PB.default_values(::Type{MetricInfo}) = (;name = nothing, display_name = "", description = "", dataset_type = DatasetType.DATASET_UNKNOWN)
PB.field_numbers(::Type{MetricInfo}) = (;name = 1, display_name = 3, description = 4, dataset_type = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MetricInfo})
    name = Ref{Union{Nothing,MetricName}}(nothing)
    display_name = ""
    description = ""
    dataset_type = DatasetType.DATASET_UNKNOWN
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, name)
        elseif field_number == 3
            display_name = PB.decode(d, String)
        elseif field_number == 4
            description = PB.decode(d, String)
        elseif field_number == 5
            dataset_type = PB.decode(d, DatasetType.T)
        else
            PB.skip(d, wire_type)
        end
    end
    return MetricInfo(name[], display_name, description, dataset_type)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MetricInfo)
    initpos = position(e.io)
    !isnothing(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.display_name) && PB.encode(e, 3, x.display_name)
    !isempty(x.description) && PB.encode(e, 4, x.description)
    x.dataset_type != DatasetType.DATASET_UNKNOWN && PB.encode(e, 5, x.dataset_type)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MetricInfo)
    encoded_size = 0
    !isnothing(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.display_name) && (encoded_size += PB._encoded_size(x.display_name, 3))
    !isempty(x.description) && (encoded_size += PB._encoded_size(x.description, 4))
    x.dataset_type != DatasetType.DATASET_UNKNOWN && (encoded_size += PB._encoded_size(x.dataset_type, 5))
    return encoded_size
end

struct MetricValue
    name::Union{Nothing,MetricName}
    value::Float64
    training_step::Int32
    wall_time_secs::Float64
end
PB.default_values(::Type{MetricValue}) = (;name = nothing, value = zero(Float64), training_step = zero(Int32), wall_time_secs = zero(Float64))
PB.field_numbers(::Type{MetricValue}) = (;name = 1, value = 2, training_step = 3, wall_time_secs = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MetricValue})
    name = Ref{Union{Nothing,MetricName}}(nothing)
    value = zero(Float64)
    training_step = zero(Int32)
    wall_time_secs = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, name)
        elseif field_number == 2
            value = PB.decode(d, Float64)
        elseif field_number == 3
            training_step = PB.decode(d, Int32)
        elseif field_number == 4
            wall_time_secs = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return MetricValue(name[], value, training_step, wall_time_secs)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MetricValue)
    initpos = position(e.io)
    !isnothing(x.name) && PB.encode(e, 1, x.name)
    x.value != zero(Float64) && PB.encode(e, 2, x.value)
    x.training_step != zero(Int32) && PB.encode(e, 3, x.training_step)
    x.wall_time_secs != zero(Float64) && PB.encode(e, 4, x.wall_time_secs)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MetricValue)
    encoded_size = 0
    !isnothing(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    x.value != zero(Float64) && (encoded_size += PB._encoded_size(x.value, 2))
    x.training_step != zero(Int32) && (encoded_size += PB._encoded_size(x.training_step, 3))
    x.wall_time_secs != zero(Float64) && (encoded_size += PB._encoded_size(x.wall_time_secs, 4))
    return encoded_size
end

struct ListSessionGroupsRequest
    experiment_name::String
    allowed_statuses::Vector{Status.T}
    col_params::Vector{ColParams}
    aggregation_type::AggregationType.T
    aggregation_metric::Union{Nothing,MetricName}
    start_index::Int32
    slice_size::Int32
end
PB.default_values(::Type{ListSessionGroupsRequest}) = (;experiment_name = "", allowed_statuses = Vector{Status.T}(), col_params = Vector{ColParams}(), aggregation_type = AggregationType.AGGREGATION_UNSET, aggregation_metric = nothing, start_index = zero(Int32), slice_size = zero(Int32))
PB.field_numbers(::Type{ListSessionGroupsRequest}) = (;experiment_name = 6, allowed_statuses = 7, col_params = 1, aggregation_type = 2, aggregation_metric = 3, start_index = 4, slice_size = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ListSessionGroupsRequest})
    experiment_name = ""
    allowed_statuses = PB.BufferedVector{Status.T}()
    col_params = PB.BufferedVector{ColParams}()
    aggregation_type = AggregationType.AGGREGATION_UNSET
    aggregation_metric = Ref{Union{Nothing,MetricName}}(nothing)
    start_index = zero(Int32)
    slice_size = zero(Int32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 6
            experiment_name = PB.decode(d, String)
        elseif field_number == 7
            PB.decode!(d, wire_type, allowed_statuses)
        elseif field_number == 1
            PB.decode!(d, col_params)
        elseif field_number == 2
            aggregation_type = PB.decode(d, AggregationType.T)
        elseif field_number == 3
            PB.decode!(d, aggregation_metric)
        elseif field_number == 4
            start_index = PB.decode(d, Int32)
        elseif field_number == 5
            slice_size = PB.decode(d, Int32)
        else
            PB.skip(d, wire_type)
        end
    end
    return ListSessionGroupsRequest(experiment_name, allowed_statuses[], col_params[], aggregation_type, aggregation_metric[], start_index, slice_size)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ListSessionGroupsRequest)
    initpos = position(e.io)
    !isempty(x.experiment_name) && PB.encode(e, 6, x.experiment_name)
    !isempty(x.allowed_statuses) && PB.encode(e, 7, x.allowed_statuses)
    !isempty(x.col_params) && PB.encode(e, 1, x.col_params)
    x.aggregation_type != AggregationType.AGGREGATION_UNSET && PB.encode(e, 2, x.aggregation_type)
    !isnothing(x.aggregation_metric) && PB.encode(e, 3, x.aggregation_metric)
    x.start_index != zero(Int32) && PB.encode(e, 4, x.start_index)
    x.slice_size != zero(Int32) && PB.encode(e, 5, x.slice_size)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ListSessionGroupsRequest)
    encoded_size = 0
    !isempty(x.experiment_name) && (encoded_size += PB._encoded_size(x.experiment_name, 6))
    !isempty(x.allowed_statuses) && (encoded_size += PB._encoded_size(x.allowed_statuses, 7))
    !isempty(x.col_params) && (encoded_size += PB._encoded_size(x.col_params, 1))
    x.aggregation_type != AggregationType.AGGREGATION_UNSET && (encoded_size += PB._encoded_size(x.aggregation_type, 2))
    !isnothing(x.aggregation_metric) && (encoded_size += PB._encoded_size(x.aggregation_metric, 3))
    x.start_index != zero(Int32) && (encoded_size += PB._encoded_size(x.start_index, 4))
    x.slice_size != zero(Int32) && (encoded_size += PB._encoded_size(x.slice_size, 5))
    return encoded_size
end

struct Experiment
    name::String
    description::String
    user::String
    time_created_secs::Float64
    hparam_infos::Vector{HParamInfo}
    metric_infos::Vector{MetricInfo}
end
PB.default_values(::Type{Experiment}) = (;name = "", description = "", user = "", time_created_secs = zero(Float64), hparam_infos = Vector{HParamInfo}(), metric_infos = Vector{MetricInfo}())
PB.field_numbers(::Type{Experiment}) = (;name = 6, description = 1, user = 2, time_created_secs = 3, hparam_infos = 4, metric_infos = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Experiment})
    name = ""
    description = ""
    user = ""
    time_created_secs = zero(Float64)
    hparam_infos = PB.BufferedVector{HParamInfo}()
    metric_infos = PB.BufferedVector{MetricInfo}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 6
            name = PB.decode(d, String)
        elseif field_number == 1
            description = PB.decode(d, String)
        elseif field_number == 2
            user = PB.decode(d, String)
        elseif field_number == 3
            time_created_secs = PB.decode(d, Float64)
        elseif field_number == 4
            PB.decode!(d, hparam_infos)
        elseif field_number == 5
            PB.decode!(d, metric_infos)
        else
            PB.skip(d, wire_type)
        end
    end
    return Experiment(name, description, user, time_created_secs, hparam_infos[], metric_infos[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Experiment)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 6, x.name)
    !isempty(x.description) && PB.encode(e, 1, x.description)
    !isempty(x.user) && PB.encode(e, 2, x.user)
    x.time_created_secs != zero(Float64) && PB.encode(e, 3, x.time_created_secs)
    !isempty(x.hparam_infos) && PB.encode(e, 4, x.hparam_infos)
    !isempty(x.metric_infos) && PB.encode(e, 5, x.metric_infos)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Experiment)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 6))
    !isempty(x.description) && (encoded_size += PB._encoded_size(x.description, 1))
    !isempty(x.user) && (encoded_size += PB._encoded_size(x.user, 2))
    x.time_created_secs != zero(Float64) && (encoded_size += PB._encoded_size(x.time_created_secs, 3))
    !isempty(x.hparam_infos) && (encoded_size += PB._encoded_size(x.hparam_infos, 4))
    !isempty(x.metric_infos) && (encoded_size += PB._encoded_size(x.metric_infos, 5))
    return encoded_size
end

struct Session
    name::String
    start_time_secs::Float64
    end_time_secs::Float64
    status::Status.T
    model_uri::String
    metric_values::Vector{MetricValue}
    monitor_url::String
end
PB.default_values(::Type{Session}) = (;name = "", start_time_secs = zero(Float64), end_time_secs = zero(Float64), status = Status.STATUS_UNKNOWN, model_uri = "", metric_values = Vector{MetricValue}(), monitor_url = "")
PB.field_numbers(::Type{Session}) = (;name = 1, start_time_secs = 2, end_time_secs = 3, status = 4, model_uri = 5, metric_values = 6, monitor_url = 7)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Session})
    name = ""
    start_time_secs = zero(Float64)
    end_time_secs = zero(Float64)
    status = Status.STATUS_UNKNOWN
    model_uri = ""
    metric_values = PB.BufferedVector{MetricValue}()
    monitor_url = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            start_time_secs = PB.decode(d, Float64)
        elseif field_number == 3
            end_time_secs = PB.decode(d, Float64)
        elseif field_number == 4
            status = PB.decode(d, Status.T)
        elseif field_number == 5
            model_uri = PB.decode(d, String)
        elseif field_number == 6
            PB.decode!(d, metric_values)
        elseif field_number == 7
            monitor_url = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return Session(name, start_time_secs, end_time_secs, status, model_uri, metric_values[], monitor_url)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Session)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    x.start_time_secs != zero(Float64) && PB.encode(e, 2, x.start_time_secs)
    x.end_time_secs != zero(Float64) && PB.encode(e, 3, x.end_time_secs)
    x.status != Status.STATUS_UNKNOWN && PB.encode(e, 4, x.status)
    !isempty(x.model_uri) && PB.encode(e, 5, x.model_uri)
    !isempty(x.metric_values) && PB.encode(e, 6, x.metric_values)
    !isempty(x.monitor_url) && PB.encode(e, 7, x.monitor_url)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Session)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    x.start_time_secs != zero(Float64) && (encoded_size += PB._encoded_size(x.start_time_secs, 2))
    x.end_time_secs != zero(Float64) && (encoded_size += PB._encoded_size(x.end_time_secs, 3))
    x.status != Status.STATUS_UNKNOWN && (encoded_size += PB._encoded_size(x.status, 4))
    !isempty(x.model_uri) && (encoded_size += PB._encoded_size(x.model_uri, 5))
    !isempty(x.metric_values) && (encoded_size += PB._encoded_size(x.metric_values, 6))
    !isempty(x.monitor_url) && (encoded_size += PB._encoded_size(x.monitor_url, 7))
    return encoded_size
end

struct SessionGroup
    name::String
    hparams::Dict{String,google.protobuf.Value}
    metric_values::Vector{MetricValue}
    sessions::Vector{Session}
    monitor_url::String
end
PB.default_values(::Type{SessionGroup}) = (;name = "", hparams = Dict{String,google.protobuf.Value}(), metric_values = Vector{MetricValue}(), sessions = Vector{Session}(), monitor_url = "")
PB.field_numbers(::Type{SessionGroup}) = (;name = 1, hparams = 2, metric_values = 3, sessions = 4, monitor_url = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SessionGroup})
    name = ""
    hparams = Dict{String,google.protobuf.Value}()
    metric_values = PB.BufferedVector{MetricValue}()
    sessions = PB.BufferedVector{Session}()
    monitor_url = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, hparams)
        elseif field_number == 3
            PB.decode!(d, metric_values)
        elseif field_number == 4
            PB.decode!(d, sessions)
        elseif field_number == 5
            monitor_url = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return SessionGroup(name, hparams, metric_values[], sessions[], monitor_url)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SessionGroup)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.hparams) && PB.encode(e, 2, x.hparams)
    !isempty(x.metric_values) && PB.encode(e, 3, x.metric_values)
    !isempty(x.sessions) && PB.encode(e, 4, x.sessions)
    !isempty(x.monitor_url) && PB.encode(e, 5, x.monitor_url)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SessionGroup)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.hparams) && (encoded_size += PB._encoded_size(x.hparams, 2))
    !isempty(x.metric_values) && (encoded_size += PB._encoded_size(x.metric_values, 3))
    !isempty(x.sessions) && (encoded_size += PB._encoded_size(x.sessions, 4))
    !isempty(x.monitor_url) && (encoded_size += PB._encoded_size(x.monitor_url, 5))
    return encoded_size
end

struct ListSessionGroupsResponse
    session_groups::Vector{SessionGroup}
    total_size::Int32
end
PB.default_values(::Type{ListSessionGroupsResponse}) = (;session_groups = Vector{SessionGroup}(), total_size = zero(Int32))
PB.field_numbers(::Type{ListSessionGroupsResponse}) = (;session_groups = 1, total_size = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ListSessionGroupsResponse})
    session_groups = PB.BufferedVector{SessionGroup}()
    total_size = zero(Int32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, session_groups)
        elseif field_number == 3
            total_size = PB.decode(d, Int32)
        else
            PB.skip(d, wire_type)
        end
    end
    return ListSessionGroupsResponse(session_groups[], total_size)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ListSessionGroupsResponse)
    initpos = position(e.io)
    !isempty(x.session_groups) && PB.encode(e, 1, x.session_groups)
    x.total_size != zero(Int32) && PB.encode(e, 3, x.total_size)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ListSessionGroupsResponse)
    encoded_size = 0
    !isempty(x.session_groups) && (encoded_size += PB._encoded_size(x.session_groups, 1))
    x.total_size != zero(Int32) && (encoded_size += PB._encoded_size(x.total_size, 3))
    return encoded_size
end
