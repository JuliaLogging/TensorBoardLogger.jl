# Autogenerated using ProtoBuf.jl v1.0.11 on 2023-08-08T14:37:02.084
# original path: proto/tensorboard/plugins/hparams/google/protobuf/struct.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export NullValue, Struct, Value, ListValue

# Abstract types to help resolve mutually recursive definitions
abstract type var"##AbstractStruct" end
abstract type var"##AbstractValue" end
abstract type var"##AbstractListValue" end


@enumx NullValue NULL_VALUE=0

struct Struct{T1<:Union{Nothing,var"##AbstractValue"}} <: var"##AbstractStruct"
    fields::Dict{String,T1}
end
PB.default_values(::Type{Struct}) = (;fields = Dict{String,Value}())
PB.field_numbers(::Type{Struct}) = (;fields = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Struct})
    fields = Dict{String,Value}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, fields)
        else
            PB.skip(d, wire_type)
        end
    end
    return Struct(fields)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Struct)
    initpos = position(e.io)
    !isempty(x.fields) && PB.encode(e, 1, x.fields)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Struct)
    encoded_size = 0
    !isempty(x.fields) && (encoded_size += PB._encoded_size(x.fields, 1))
    return encoded_size
end

struct Value <: var"##AbstractValue"
    kind::Union{Nothing,OneOf{<:Union{NullValue.T,Float64,String,Bool,var"##AbstractStruct",var"##AbstractListValue"}}}
end
PB.oneof_field_types(::Type{Value}) = (;
    kind = (;null_value=NullValue.T, number_value=Float64, string_value=String, bool_value=Bool, struct_value=Struct, list_value=ListValue),
)
PB.default_values(::Type{Value}) = (;null_value = NullValue.NULL_VALUE, number_value = zero(Float64), string_value = "", bool_value = false, struct_value = nothing, list_value = nothing)
PB.field_numbers(::Type{Value}) = (;null_value = 1, number_value = 2, string_value = 3, bool_value = 4, struct_value = 5, list_value = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Value})
    kind = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            kind = OneOf(:null_value, PB.decode(d, NullValue.T))
        elseif field_number == 2
            kind = OneOf(:number_value, PB.decode(d, Float64))
        elseif field_number == 3
            kind = OneOf(:string_value, PB.decode(d, String))
        elseif field_number == 4
            kind = OneOf(:bool_value, PB.decode(d, Bool))
        elseif field_number == 5
            kind = OneOf(:struct_value, PB.decode(d, Ref{Struct}))
        elseif field_number == 6
            kind = OneOf(:list_value, PB.decode(d, Ref{ListValue}))
        else
            PB.skip(d, wire_type)
        end
    end
    return Value(kind)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Value)
    initpos = position(e.io)
    if isnothing(x.kind);
    elseif x.kind.name === :null_value
        PB.encode(e, 1, x.kind[]::NullValue.T)
    elseif x.kind.name === :number_value
        PB.encode(e, 2, x.kind[]::Float64)
    elseif x.kind.name === :string_value
        PB.encode(e, 3, x.kind[]::String)
    elseif x.kind.name === :bool_value
        PB.encode(e, 4, x.kind[]::Bool)
    elseif x.kind.name === :struct_value
        PB.encode(e, 5, x.kind[]::Struct)
    elseif x.kind.name === :list_value
        PB.encode(e, 6, x.kind[]::ListValue)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Value)
    encoded_size = 0
    if isnothing(x.kind);
    elseif x.kind.name === :null_value
        encoded_size += PB._encoded_size(x.kind[]::NullValue.T, 1)
    elseif x.kind.name === :number_value
        encoded_size += PB._encoded_size(x.kind[]::Float64, 2)
    elseif x.kind.name === :string_value
        encoded_size += PB._encoded_size(x.kind[]::String, 3)
    elseif x.kind.name === :bool_value
        encoded_size += PB._encoded_size(x.kind[]::Bool, 4)
    elseif x.kind.name === :struct_value
        encoded_size += PB._encoded_size(x.kind[]::Struct, 5)
    elseif x.kind.name === :list_value
        encoded_size += PB._encoded_size(x.kind[]::ListValue, 6)
    end
    return encoded_size
end

struct ListValue <: var"##AbstractListValue"
    values::Vector{<:Value}
end
PB.default_values(::Type{ListValue}) = (;values = Vector{Value}())
PB.field_numbers(::Type{ListValue}) = (;values = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ListValue})
    values = PB.BufferedVector{Value}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, values)
        else
            PB.skip(d, wire_type)
        end
    end
    return ListValue(values[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ListValue)
    initpos = position(e.io)
    !isempty(x.values) && PB.encode(e, 1, x.values)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ListValue)
    encoded_size = 0
    !isempty(x.values) && (encoded_size += PB._encoded_size(x.values, 1))
    return encoded_size
end