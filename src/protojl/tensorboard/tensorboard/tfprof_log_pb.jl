# Autogenerated using ProtoBuf.jl v1.0.11 on 2023-06-19T18:18:24.776
# original file: /home/lior/TensorBoardLogger.jl/gen/proto/tensorboard/compat/proto/tfprof_log.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export Tuple, Memory, var"CodeDef.Trace", ExecTime, ExecMemory, CodeDef, ExecProfile
export OpLogEntry, ProfileNode, OpLogProto, ProfileProto

struct Tuple
    int64_values::Vector{Int64}
end
PB.default_values(::Type{Tuple}) = (;int64_values = Vector{Int64}())
PB.field_numbers(::Type{Tuple}) = (;int64_values = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Tuple})
    int64_values = PB.BufferedVector{Int64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, int64_values)
        else
            PB.skip(d, wire_type)
        end
    end
    return Tuple(int64_values[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Tuple)
    initpos = position(e.io)
    !isempty(x.int64_values) && PB.encode(e, 1, x.int64_values)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Tuple)
    encoded_size = 0
    !isempty(x.int64_values) && (encoded_size += PB._encoded_size(x.int64_values, 1))
    return encoded_size
end

struct Memory
    bytes::Int64
    ptr::UInt64
end
PB.default_values(::Type{Memory}) = (;bytes = zero(Int64), ptr = zero(UInt64))
PB.field_numbers(::Type{Memory}) = (;bytes = 1, ptr = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Memory})
    bytes = zero(Int64)
    ptr = zero(UInt64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            bytes = PB.decode(d, Int64)
        elseif field_number == 2
            ptr = PB.decode(d, UInt64)
        else
            PB.skip(d, wire_type)
        end
    end
    return Memory(bytes, ptr)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Memory)
    initpos = position(e.io)
    x.bytes != zero(Int64) && PB.encode(e, 1, x.bytes)
    x.ptr != zero(UInt64) && PB.encode(e, 2, x.ptr)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Memory)
    encoded_size = 0
    x.bytes != zero(Int64) && (encoded_size += PB._encoded_size(x.bytes, 1))
    x.ptr != zero(UInt64) && (encoded_size += PB._encoded_size(x.ptr, 2))
    return encoded_size
end

struct var"CodeDef.Trace"
    file::String
    file_id::Int64
    lineno::Int32
    var"#function"::String
    function_id::Int64
    line::String
    line_id::Int64
    func_start_line::Int32
end
PB.default_values(::Type{var"CodeDef.Trace"}) = (;file = "", file_id = zero(Int64), lineno = zero(Int32), var"#function" = "", function_id = zero(Int64), line = "", line_id = zero(Int64), func_start_line = zero(Int32))
PB.field_numbers(::Type{var"CodeDef.Trace"}) = (;file = 1, file_id = 6, lineno = 2, var"#function" = 3, function_id = 7, line = 4, line_id = 8, func_start_line = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"CodeDef.Trace"})
    file = ""
    file_id = zero(Int64)
    lineno = zero(Int32)
    var"#function" = ""
    function_id = zero(Int64)
    line = ""
    line_id = zero(Int64)
    func_start_line = zero(Int32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            file = PB.decode(d, String)
        elseif field_number == 6
            file_id = PB.decode(d, Int64)
        elseif field_number == 2
            lineno = PB.decode(d, Int32)
        elseif field_number == 3
            var"#function" = PB.decode(d, String)
        elseif field_number == 7
            function_id = PB.decode(d, Int64)
        elseif field_number == 4
            line = PB.decode(d, String)
        elseif field_number == 8
            line_id = PB.decode(d, Int64)
        elseif field_number == 5
            func_start_line = PB.decode(d, Int32)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"CodeDef.Trace"(file, file_id, lineno, var"#function", function_id, line, line_id, func_start_line)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"CodeDef.Trace")
    initpos = position(e.io)
    !isempty(x.file) && PB.encode(e, 1, x.file)
    x.file_id != zero(Int64) && PB.encode(e, 6, x.file_id)
    x.lineno != zero(Int32) && PB.encode(e, 2, x.lineno)
    !isempty(x.var"#function") && PB.encode(e, 3, x.var"#function")
    x.function_id != zero(Int64) && PB.encode(e, 7, x.function_id)
    !isempty(x.line) && PB.encode(e, 4, x.line)
    x.line_id != zero(Int64) && PB.encode(e, 8, x.line_id)
    x.func_start_line != zero(Int32) && PB.encode(e, 5, x.func_start_line)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"CodeDef.Trace")
    encoded_size = 0
    !isempty(x.file) && (encoded_size += PB._encoded_size(x.file, 1))
    x.file_id != zero(Int64) && (encoded_size += PB._encoded_size(x.file_id, 6))
    x.lineno != zero(Int32) && (encoded_size += PB._encoded_size(x.lineno, 2))
    !isempty(x.var"#function") && (encoded_size += PB._encoded_size(x.var"#function", 3))
    x.function_id != zero(Int64) && (encoded_size += PB._encoded_size(x.function_id, 7))
    !isempty(x.line) && (encoded_size += PB._encoded_size(x.line, 4))
    x.line_id != zero(Int64) && (encoded_size += PB._encoded_size(x.line_id, 8))
    x.func_start_line != zero(Int32) && (encoded_size += PB._encoded_size(x.func_start_line, 5))
    return encoded_size
end

struct ExecTime
    times::Vector{Tuple}
end
PB.default_values(::Type{ExecTime}) = (;times = Vector{Tuple}())
PB.field_numbers(::Type{ExecTime}) = (;times = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ExecTime})
    times = PB.BufferedVector{Tuple}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, times)
        else
            PB.skip(d, wire_type)
        end
    end
    return ExecTime(times[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ExecTime)
    initpos = position(e.io)
    !isempty(x.times) && PB.encode(e, 1, x.times)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ExecTime)
    encoded_size = 0
    !isempty(x.times) && (encoded_size += PB._encoded_size(x.times, 1))
    return encoded_size
end

struct ExecMemory
    memory_micros::Int64
    host_temp_bytes::Int64
    host_persistent_bytes::Int64
    accelerator_temp_bytes::Int64
    accelerator_persistent_bytes::Int64
    requested_bytes::Int64
    peak_bytes::Int64
    residual_bytes::Int64
    output_bytes::Int64
    allocator_bytes_in_use::Int64
    output_memory::Dict{Int32,Memory}
end
PB.default_values(::Type{ExecMemory}) = (;memory_micros = zero(Int64), host_temp_bytes = zero(Int64), host_persistent_bytes = zero(Int64), accelerator_temp_bytes = zero(Int64), accelerator_persistent_bytes = zero(Int64), requested_bytes = zero(Int64), peak_bytes = zero(Int64), residual_bytes = zero(Int64), output_bytes = zero(Int64), allocator_bytes_in_use = zero(Int64), output_memory = Dict{Int32,Memory}())
PB.field_numbers(::Type{ExecMemory}) = (;memory_micros = 1, host_temp_bytes = 2, host_persistent_bytes = 3, accelerator_temp_bytes = 4, accelerator_persistent_bytes = 5, requested_bytes = 6, peak_bytes = 7, residual_bytes = 8, output_bytes = 9, allocator_bytes_in_use = 10, output_memory = 11)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ExecMemory})
    memory_micros = zero(Int64)
    host_temp_bytes = zero(Int64)
    host_persistent_bytes = zero(Int64)
    accelerator_temp_bytes = zero(Int64)
    accelerator_persistent_bytes = zero(Int64)
    requested_bytes = zero(Int64)
    peak_bytes = zero(Int64)
    residual_bytes = zero(Int64)
    output_bytes = zero(Int64)
    allocator_bytes_in_use = zero(Int64)
    output_memory = Dict{Int32,Memory}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            memory_micros = PB.decode(d, Int64)
        elseif field_number == 2
            host_temp_bytes = PB.decode(d, Int64)
        elseif field_number == 3
            host_persistent_bytes = PB.decode(d, Int64)
        elseif field_number == 4
            accelerator_temp_bytes = PB.decode(d, Int64)
        elseif field_number == 5
            accelerator_persistent_bytes = PB.decode(d, Int64)
        elseif field_number == 6
            requested_bytes = PB.decode(d, Int64)
        elseif field_number == 7
            peak_bytes = PB.decode(d, Int64)
        elseif field_number == 8
            residual_bytes = PB.decode(d, Int64)
        elseif field_number == 9
            output_bytes = PB.decode(d, Int64)
        elseif field_number == 10
            allocator_bytes_in_use = PB.decode(d, Int64)
        elseif field_number == 11
            PB.decode!(d, output_memory)
        else
            PB.skip(d, wire_type)
        end
    end
    return ExecMemory(memory_micros, host_temp_bytes, host_persistent_bytes, accelerator_temp_bytes, accelerator_persistent_bytes, requested_bytes, peak_bytes, residual_bytes, output_bytes, allocator_bytes_in_use, output_memory)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ExecMemory)
    initpos = position(e.io)
    x.memory_micros != zero(Int64) && PB.encode(e, 1, x.memory_micros)
    x.host_temp_bytes != zero(Int64) && PB.encode(e, 2, x.host_temp_bytes)
    x.host_persistent_bytes != zero(Int64) && PB.encode(e, 3, x.host_persistent_bytes)
    x.accelerator_temp_bytes != zero(Int64) && PB.encode(e, 4, x.accelerator_temp_bytes)
    x.accelerator_persistent_bytes != zero(Int64) && PB.encode(e, 5, x.accelerator_persistent_bytes)
    x.requested_bytes != zero(Int64) && PB.encode(e, 6, x.requested_bytes)
    x.peak_bytes != zero(Int64) && PB.encode(e, 7, x.peak_bytes)
    x.residual_bytes != zero(Int64) && PB.encode(e, 8, x.residual_bytes)
    x.output_bytes != zero(Int64) && PB.encode(e, 9, x.output_bytes)
    x.allocator_bytes_in_use != zero(Int64) && PB.encode(e, 10, x.allocator_bytes_in_use)
    !isempty(x.output_memory) && PB.encode(e, 11, x.output_memory)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ExecMemory)
    encoded_size = 0
    x.memory_micros != zero(Int64) && (encoded_size += PB._encoded_size(x.memory_micros, 1))
    x.host_temp_bytes != zero(Int64) && (encoded_size += PB._encoded_size(x.host_temp_bytes, 2))
    x.host_persistent_bytes != zero(Int64) && (encoded_size += PB._encoded_size(x.host_persistent_bytes, 3))
    x.accelerator_temp_bytes != zero(Int64) && (encoded_size += PB._encoded_size(x.accelerator_temp_bytes, 4))
    x.accelerator_persistent_bytes != zero(Int64) && (encoded_size += PB._encoded_size(x.accelerator_persistent_bytes, 5))
    x.requested_bytes != zero(Int64) && (encoded_size += PB._encoded_size(x.requested_bytes, 6))
    x.peak_bytes != zero(Int64) && (encoded_size += PB._encoded_size(x.peak_bytes, 7))
    x.residual_bytes != zero(Int64) && (encoded_size += PB._encoded_size(x.residual_bytes, 8))
    x.output_bytes != zero(Int64) && (encoded_size += PB._encoded_size(x.output_bytes, 9))
    x.allocator_bytes_in_use != zero(Int64) && (encoded_size += PB._encoded_size(x.allocator_bytes_in_use, 10))
    !isempty(x.output_memory) && (encoded_size += PB._encoded_size(x.output_memory, 11))
    return encoded_size
end

struct CodeDef
    traces::Vector{var"CodeDef.Trace"}
end
PB.default_values(::Type{CodeDef}) = (;traces = Vector{var"CodeDef.Trace"}())
PB.field_numbers(::Type{CodeDef}) = (;traces = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CodeDef})
    traces = PB.BufferedVector{var"CodeDef.Trace"}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, traces)
        else
            PB.skip(d, wire_type)
        end
    end
    return CodeDef(traces[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CodeDef)
    initpos = position(e.io)
    !isempty(x.traces) && PB.encode(e, 1, x.traces)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CodeDef)
    encoded_size = 0
    !isempty(x.traces) && (encoded_size += PB._encoded_size(x.traces, 1))
    return encoded_size
end

struct ExecProfile
    run_count::Int64
    all_start_micros::Int64
    latest_end_micros::Int64
    accelerator_execs::Dict{String,ExecTime}
    cpu_execs::Dict{String,ExecTime}
    memory_execs::Vector{ExecMemory}
    allocations::Vector{AllocationRecord}
    devices::Vector{String}
end
PB.default_values(::Type{ExecProfile}) = (;run_count = zero(Int64), all_start_micros = zero(Int64), latest_end_micros = zero(Int64), accelerator_execs = Dict{String,ExecTime}(), cpu_execs = Dict{String,ExecTime}(), memory_execs = Vector{ExecMemory}(), allocations = Vector{AllocationRecord}(), devices = Vector{String}())
PB.field_numbers(::Type{ExecProfile}) = (;run_count = 1, all_start_micros = 2, latest_end_micros = 3, accelerator_execs = 4, cpu_execs = 5, memory_execs = 7, allocations = 11, devices = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ExecProfile})
    run_count = zero(Int64)
    all_start_micros = zero(Int64)
    latest_end_micros = zero(Int64)
    accelerator_execs = Dict{String,ExecTime}()
    cpu_execs = Dict{String,ExecTime}()
    memory_execs = PB.BufferedVector{ExecMemory}()
    allocations = PB.BufferedVector{AllocationRecord}()
    devices = PB.BufferedVector{String}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            run_count = PB.decode(d, Int64)
        elseif field_number == 2
            all_start_micros = PB.decode(d, Int64)
        elseif field_number == 3
            latest_end_micros = PB.decode(d, Int64)
        elseif field_number == 4
            PB.decode!(d, accelerator_execs)
        elseif field_number == 5
            PB.decode!(d, cpu_execs)
        elseif field_number == 7
            PB.decode!(d, memory_execs)
        elseif field_number == 11
            PB.decode!(d, allocations)
        elseif field_number == 6
            PB.decode!(d, devices)
        else
            PB.skip(d, wire_type)
        end
    end
    return ExecProfile(run_count, all_start_micros, latest_end_micros, accelerator_execs, cpu_execs, memory_execs[], allocations[], devices[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ExecProfile)
    initpos = position(e.io)
    x.run_count != zero(Int64) && PB.encode(e, 1, x.run_count)
    x.all_start_micros != zero(Int64) && PB.encode(e, 2, x.all_start_micros)
    x.latest_end_micros != zero(Int64) && PB.encode(e, 3, x.latest_end_micros)
    !isempty(x.accelerator_execs) && PB.encode(e, 4, x.accelerator_execs)
    !isempty(x.cpu_execs) && PB.encode(e, 5, x.cpu_execs)
    !isempty(x.memory_execs) && PB.encode(e, 7, x.memory_execs)
    !isempty(x.allocations) && PB.encode(e, 11, x.allocations)
    !isempty(x.devices) && PB.encode(e, 6, x.devices)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ExecProfile)
    encoded_size = 0
    x.run_count != zero(Int64) && (encoded_size += PB._encoded_size(x.run_count, 1))
    x.all_start_micros != zero(Int64) && (encoded_size += PB._encoded_size(x.all_start_micros, 2))
    x.latest_end_micros != zero(Int64) && (encoded_size += PB._encoded_size(x.latest_end_micros, 3))
    !isempty(x.accelerator_execs) && (encoded_size += PB._encoded_size(x.accelerator_execs, 4))
    !isempty(x.cpu_execs) && (encoded_size += PB._encoded_size(x.cpu_execs, 5))
    !isempty(x.memory_execs) && (encoded_size += PB._encoded_size(x.memory_execs, 7))
    !isempty(x.allocations) && (encoded_size += PB._encoded_size(x.allocations, 11))
    !isempty(x.devices) && (encoded_size += PB._encoded_size(x.devices, 6))
    return encoded_size
end

struct OpLogEntry
    name::String
    float_ops::Int64
    types::Vector{String}
    code_def::Union{Nothing,CodeDef}
end
PB.default_values(::Type{OpLogEntry}) = (;name = "", float_ops = zero(Int64), types = Vector{String}(), code_def = nothing)
PB.field_numbers(::Type{OpLogEntry}) = (;name = 1, float_ops = 2, types = 3, code_def = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:OpLogEntry})
    name = ""
    float_ops = zero(Int64)
    types = PB.BufferedVector{String}()
    code_def = Ref{Union{Nothing,CodeDef}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            float_ops = PB.decode(d, Int64)
        elseif field_number == 3
            PB.decode!(d, types)
        elseif field_number == 4
            PB.decode!(d, code_def)
        else
            PB.skip(d, wire_type)
        end
    end
    return OpLogEntry(name, float_ops, types[], code_def[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::OpLogEntry)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    x.float_ops != zero(Int64) && PB.encode(e, 2, x.float_ops)
    !isempty(x.types) && PB.encode(e, 3, x.types)
    !isnothing(x.code_def) && PB.encode(e, 4, x.code_def)
    return position(e.io) - initpos
end
function PB._encoded_size(x::OpLogEntry)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    x.float_ops != zero(Int64) && (encoded_size += PB._encoded_size(x.float_ops, 2))
    !isempty(x.types) && (encoded_size += PB._encoded_size(x.types, 3))
    !isnothing(x.code_def) && (encoded_size += PB._encoded_size(x.code_def, 4))
    return encoded_size
end

struct ProfileNode
    name::String
    op::String
    id::Int64
    inputs::Dict{Int32,Int64}
    input_shapes::Dict{Int32,Tuple}
    outputs::Dict{Int32,Int64}
    output_shapes::Dict{Int32,Tuple}
    src_output_index::Dict{Int64,Int32}
    shape::Vector{Int64}
    op_types::Vector{String}
    canonical_device::String
    host_device::String
    float_ops::Int64
    trace::Union{Nothing,CodeDef}
    attrs::Dict{String,AttrValue}
    execs::Dict{Int64,ExecProfile}
end
PB.default_values(::Type{ProfileNode}) = (;name = "", op = "", id = zero(Int64), inputs = Dict{Int32,Int64}(), input_shapes = Dict{Int32,Tuple}(), outputs = Dict{Int32,Int64}(), output_shapes = Dict{Int32,Tuple}(), src_output_index = Dict{Int64,Int32}(), shape = Vector{Int64}(), op_types = Vector{String}(), canonical_device = "", host_device = "", float_ops = zero(Int64), trace = nothing, attrs = Dict{String,AttrValue}(), execs = Dict{Int64,ExecProfile}())
PB.field_numbers(::Type{ProfileNode}) = (;name = 1, op = 9, id = 13, inputs = 2, input_shapes = 16, outputs = 3, output_shapes = 15, src_output_index = 14, shape = 4, op_types = 5, canonical_device = 6, host_device = 7, float_ops = 8, trace = 10, attrs = 11, execs = 12)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ProfileNode})
    name = ""
    op = ""
    id = zero(Int64)
    inputs = Dict{Int32,Int64}()
    input_shapes = Dict{Int32,Tuple}()
    outputs = Dict{Int32,Int64}()
    output_shapes = Dict{Int32,Tuple}()
    src_output_index = Dict{Int64,Int32}()
    shape = PB.BufferedVector{Int64}()
    op_types = PB.BufferedVector{String}()
    canonical_device = ""
    host_device = ""
    float_ops = zero(Int64)
    trace = Ref{Union{Nothing,CodeDef}}(nothing)
    attrs = Dict{String,AttrValue}()
    execs = Dict{Int64,ExecProfile}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 9
            op = PB.decode(d, String)
        elseif field_number == 13
            id = PB.decode(d, Int64)
        elseif field_number == 2
            PB.decode!(d, inputs)
        elseif field_number == 16
            PB.decode!(d, input_shapes)
        elseif field_number == 3
            PB.decode!(d, outputs)
        elseif field_number == 15
            PB.decode!(d, output_shapes)
        elseif field_number == 14
            PB.decode!(d, src_output_index)
        elseif field_number == 4
            PB.decode!(d, wire_type, shape)
        elseif field_number == 5
            PB.decode!(d, op_types)
        elseif field_number == 6
            canonical_device = PB.decode(d, String)
        elseif field_number == 7
            host_device = PB.decode(d, String)
        elseif field_number == 8
            float_ops = PB.decode(d, Int64)
        elseif field_number == 10
            PB.decode!(d, trace)
        elseif field_number == 11
            PB.decode!(d, attrs)
        elseif field_number == 12
            PB.decode!(d, execs)
        else
            PB.skip(d, wire_type)
        end
    end
    return ProfileNode(name, op, id, inputs, input_shapes, outputs, output_shapes, src_output_index, shape[], op_types[], canonical_device, host_device, float_ops, trace[], attrs, execs)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ProfileNode)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.op) && PB.encode(e, 9, x.op)
    x.id != zero(Int64) && PB.encode(e, 13, x.id)
    !isempty(x.inputs) && PB.encode(e, 2, x.inputs)
    !isempty(x.input_shapes) && PB.encode(e, 16, x.input_shapes)
    !isempty(x.outputs) && PB.encode(e, 3, x.outputs)
    !isempty(x.output_shapes) && PB.encode(e, 15, x.output_shapes)
    !isempty(x.src_output_index) && PB.encode(e, 14, x.src_output_index)
    !isempty(x.shape) && PB.encode(e, 4, x.shape)
    !isempty(x.op_types) && PB.encode(e, 5, x.op_types)
    !isempty(x.canonical_device) && PB.encode(e, 6, x.canonical_device)
    !isempty(x.host_device) && PB.encode(e, 7, x.host_device)
    x.float_ops != zero(Int64) && PB.encode(e, 8, x.float_ops)
    !isnothing(x.trace) && PB.encode(e, 10, x.trace)
    !isempty(x.attrs) && PB.encode(e, 11, x.attrs)
    !isempty(x.execs) && PB.encode(e, 12, x.execs)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ProfileNode)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.op) && (encoded_size += PB._encoded_size(x.op, 9))
    x.id != zero(Int64) && (encoded_size += PB._encoded_size(x.id, 13))
    !isempty(x.inputs) && (encoded_size += PB._encoded_size(x.inputs, 2))
    !isempty(x.input_shapes) && (encoded_size += PB._encoded_size(x.input_shapes, 16))
    !isempty(x.outputs) && (encoded_size += PB._encoded_size(x.outputs, 3))
    !isempty(x.output_shapes) && (encoded_size += PB._encoded_size(x.output_shapes, 15))
    !isempty(x.src_output_index) && (encoded_size += PB._encoded_size(x.src_output_index, 14))
    !isempty(x.shape) && (encoded_size += PB._encoded_size(x.shape, 4))
    !isempty(x.op_types) && (encoded_size += PB._encoded_size(x.op_types, 5))
    !isempty(x.canonical_device) && (encoded_size += PB._encoded_size(x.canonical_device, 6))
    !isempty(x.host_device) && (encoded_size += PB._encoded_size(x.host_device, 7))
    x.float_ops != zero(Int64) && (encoded_size += PB._encoded_size(x.float_ops, 8))
    !isnothing(x.trace) && (encoded_size += PB._encoded_size(x.trace, 10))
    !isempty(x.attrs) && (encoded_size += PB._encoded_size(x.attrs, 11))
    !isempty(x.execs) && (encoded_size += PB._encoded_size(x.execs, 12))
    return encoded_size
end

struct OpLogProto
    log_entries::Vector{OpLogEntry}
    id_to_string::Dict{Int64,String}
end
PB.default_values(::Type{OpLogProto}) = (;log_entries = Vector{OpLogEntry}(), id_to_string = Dict{Int64,String}())
PB.field_numbers(::Type{OpLogProto}) = (;log_entries = 1, id_to_string = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:OpLogProto})
    log_entries = PB.BufferedVector{OpLogEntry}()
    id_to_string = Dict{Int64,String}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, log_entries)
        elseif field_number == 2
            PB.decode!(d, id_to_string)
        else
            PB.skip(d, wire_type)
        end
    end
    return OpLogProto(log_entries[], id_to_string)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::OpLogProto)
    initpos = position(e.io)
    !isempty(x.log_entries) && PB.encode(e, 1, x.log_entries)
    !isempty(x.id_to_string) && PB.encode(e, 2, x.id_to_string)
    return position(e.io) - initpos
end
function PB._encoded_size(x::OpLogProto)
    encoded_size = 0
    !isempty(x.log_entries) && (encoded_size += PB._encoded_size(x.log_entries, 1))
    !isempty(x.id_to_string) && (encoded_size += PB._encoded_size(x.id_to_string, 2))
    return encoded_size
end

struct ProfileProto
    nodes::Dict{Int64,ProfileNode}
    has_trace::Bool
    miss_accelerator_stream::Bool
    steps::Vector{Int64}
    id_to_string::Dict{Int64,String}
end
PB.default_values(::Type{ProfileProto}) = (;nodes = Dict{Int64,ProfileNode}(), has_trace = false, miss_accelerator_stream = false, steps = Vector{Int64}(), id_to_string = Dict{Int64,String}())
PB.field_numbers(::Type{ProfileProto}) = (;nodes = 1, has_trace = 2, miss_accelerator_stream = 5, steps = 3, id_to_string = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ProfileProto})
    nodes = Dict{Int64,ProfileNode}()
    has_trace = false
    miss_accelerator_stream = false
    steps = PB.BufferedVector{Int64}()
    id_to_string = Dict{Int64,String}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, nodes)
        elseif field_number == 2
            has_trace = PB.decode(d, Bool)
        elseif field_number == 5
            miss_accelerator_stream = PB.decode(d, Bool)
        elseif field_number == 3
            PB.decode!(d, wire_type, steps)
        elseif field_number == 4
            PB.decode!(d, id_to_string)
        else
            PB.skip(d, wire_type)
        end
    end
    return ProfileProto(nodes, has_trace, miss_accelerator_stream, steps[], id_to_string)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ProfileProto)
    initpos = position(e.io)
    !isempty(x.nodes) && PB.encode(e, 1, x.nodes)
    x.has_trace != false && PB.encode(e, 2, x.has_trace)
    x.miss_accelerator_stream != false && PB.encode(e, 5, x.miss_accelerator_stream)
    !isempty(x.steps) && PB.encode(e, 3, x.steps)
    !isempty(x.id_to_string) && PB.encode(e, 4, x.id_to_string)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ProfileProto)
    encoded_size = 0
    !isempty(x.nodes) && (encoded_size += PB._encoded_size(x.nodes, 1))
    x.has_trace != false && (encoded_size += PB._encoded_size(x.has_trace, 2))
    x.miss_accelerator_stream != false && (encoded_size += PB._encoded_size(x.miss_accelerator_stream, 5))
    !isempty(x.steps) && (encoded_size += PB._encoded_size(x.steps, 3))
    !isempty(x.id_to_string) && (encoded_size += PB._encoded_size(x.id_to_string, 4))
    return encoded_size
end
