# Autogenerated using ProtoBuf.jl v1.0.11 on 2023-08-09T10:18:18.381
# original file: proto/tensorboard/tensorboard/step_stats.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export MemoryStats, AllocationRecord, NodeOutput, AllocatorMemoryUsed, NodeExecStats
export DeviceStepStats, StepStats

struct MemoryStats
    temp_memory_size::Int64
    persistent_memory_size::Int64
    persistent_tensor_alloc_ids::Vector{Int64}
    device_temp_memory_size::Int64
    device_persistent_memory_size::Int64
    device_persistent_tensor_alloc_ids::Vector{Int64}
end
PB.default_values(::Type{MemoryStats}) = (;temp_memory_size = zero(Int64), persistent_memory_size = zero(Int64), persistent_tensor_alloc_ids = Vector{Int64}(), device_temp_memory_size = zero(Int64), device_persistent_memory_size = zero(Int64), device_persistent_tensor_alloc_ids = Vector{Int64}())
PB.field_numbers(::Type{MemoryStats}) = (;temp_memory_size = 1, persistent_memory_size = 3, persistent_tensor_alloc_ids = 5, device_temp_memory_size = 2, device_persistent_memory_size = 4, device_persistent_tensor_alloc_ids = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MemoryStats})
    temp_memory_size = zero(Int64)
    persistent_memory_size = zero(Int64)
    persistent_tensor_alloc_ids = PB.BufferedVector{Int64}()
    device_temp_memory_size = zero(Int64)
    device_persistent_memory_size = zero(Int64)
    device_persistent_tensor_alloc_ids = PB.BufferedVector{Int64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            temp_memory_size = PB.decode(d, Int64)
        elseif field_number == 3
            persistent_memory_size = PB.decode(d, Int64)
        elseif field_number == 5
            PB.decode!(d, wire_type, persistent_tensor_alloc_ids)
        elseif field_number == 2
            device_temp_memory_size = PB.decode(d, Int64)
        elseif field_number == 4
            device_persistent_memory_size = PB.decode(d, Int64)
        elseif field_number == 6
            PB.decode!(d, wire_type, device_persistent_tensor_alloc_ids)
        else
            PB.skip(d, wire_type)
        end
    end
    return MemoryStats(temp_memory_size, persistent_memory_size, persistent_tensor_alloc_ids[], device_temp_memory_size, device_persistent_memory_size, device_persistent_tensor_alloc_ids[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MemoryStats)
    initpos = position(e.io)
    x.temp_memory_size != zero(Int64) && PB.encode(e, 1, x.temp_memory_size)
    x.persistent_memory_size != zero(Int64) && PB.encode(e, 3, x.persistent_memory_size)
    !isempty(x.persistent_tensor_alloc_ids) && PB.encode(e, 5, x.persistent_tensor_alloc_ids)
    x.device_temp_memory_size != zero(Int64) && PB.encode(e, 2, x.device_temp_memory_size)
    x.device_persistent_memory_size != zero(Int64) && PB.encode(e, 4, x.device_persistent_memory_size)
    !isempty(x.device_persistent_tensor_alloc_ids) && PB.encode(e, 6, x.device_persistent_tensor_alloc_ids)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MemoryStats)
    encoded_size = 0
    x.temp_memory_size != zero(Int64) && (encoded_size += PB._encoded_size(x.temp_memory_size, 1))
    x.persistent_memory_size != zero(Int64) && (encoded_size += PB._encoded_size(x.persistent_memory_size, 3))
    !isempty(x.persistent_tensor_alloc_ids) && (encoded_size += PB._encoded_size(x.persistent_tensor_alloc_ids, 5))
    x.device_temp_memory_size != zero(Int64) && (encoded_size += PB._encoded_size(x.device_temp_memory_size, 2))
    x.device_persistent_memory_size != zero(Int64) && (encoded_size += PB._encoded_size(x.device_persistent_memory_size, 4))
    !isempty(x.device_persistent_tensor_alloc_ids) && (encoded_size += PB._encoded_size(x.device_persistent_tensor_alloc_ids, 6))
    return encoded_size
end

struct AllocationRecord
    alloc_micros::Int64
    alloc_bytes::Int64
end
PB.default_values(::Type{AllocationRecord}) = (;alloc_micros = zero(Int64), alloc_bytes = zero(Int64))
PB.field_numbers(::Type{AllocationRecord}) = (;alloc_micros = 1, alloc_bytes = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:AllocationRecord})
    alloc_micros = zero(Int64)
    alloc_bytes = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            alloc_micros = PB.decode(d, Int64)
        elseif field_number == 2
            alloc_bytes = PB.decode(d, Int64)
        else
            PB.skip(d, wire_type)
        end
    end
    return AllocationRecord(alloc_micros, alloc_bytes)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::AllocationRecord)
    initpos = position(e.io)
    x.alloc_micros != zero(Int64) && PB.encode(e, 1, x.alloc_micros)
    x.alloc_bytes != zero(Int64) && PB.encode(e, 2, x.alloc_bytes)
    return position(e.io) - initpos
end
function PB._encoded_size(x::AllocationRecord)
    encoded_size = 0
    x.alloc_micros != zero(Int64) && (encoded_size += PB._encoded_size(x.alloc_micros, 1))
    x.alloc_bytes != zero(Int64) && (encoded_size += PB._encoded_size(x.alloc_bytes, 2))
    return encoded_size
end

struct NodeOutput
    slot::Int32
    tensor_description::Union{Nothing,TensorDescription}
end
PB.default_values(::Type{NodeOutput}) = (;slot = zero(Int32), tensor_description = nothing)
PB.field_numbers(::Type{NodeOutput}) = (;slot = 1, tensor_description = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:NodeOutput})
    slot = zero(Int32)
    tensor_description = Ref{Union{Nothing,TensorDescription}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            slot = PB.decode(d, Int32)
        elseif field_number == 3
            PB.decode!(d, tensor_description)
        else
            PB.skip(d, wire_type)
        end
    end
    return NodeOutput(slot, tensor_description[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::NodeOutput)
    initpos = position(e.io)
    x.slot != zero(Int32) && PB.encode(e, 1, x.slot)
    !isnothing(x.tensor_description) && PB.encode(e, 3, x.tensor_description)
    return position(e.io) - initpos
end
function PB._encoded_size(x::NodeOutput)
    encoded_size = 0
    x.slot != zero(Int32) && (encoded_size += PB._encoded_size(x.slot, 1))
    !isnothing(x.tensor_description) && (encoded_size += PB._encoded_size(x.tensor_description, 3))
    return encoded_size
end

struct AllocatorMemoryUsed
    allocator_name::String
    total_bytes::Int64
    peak_bytes::Int64
    live_bytes::Int64
    allocation_records::Vector{AllocationRecord}
    allocator_bytes_in_use::Int64
end
PB.default_values(::Type{AllocatorMemoryUsed}) = (;allocator_name = "", total_bytes = zero(Int64), peak_bytes = zero(Int64), live_bytes = zero(Int64), allocation_records = Vector{AllocationRecord}(), allocator_bytes_in_use = zero(Int64))
PB.field_numbers(::Type{AllocatorMemoryUsed}) = (;allocator_name = 1, total_bytes = 2, peak_bytes = 3, live_bytes = 4, allocation_records = 6, allocator_bytes_in_use = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:AllocatorMemoryUsed})
    allocator_name = ""
    total_bytes = zero(Int64)
    peak_bytes = zero(Int64)
    live_bytes = zero(Int64)
    allocation_records = PB.BufferedVector{AllocationRecord}()
    allocator_bytes_in_use = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            allocator_name = PB.decode(d, String)
        elseif field_number == 2
            total_bytes = PB.decode(d, Int64)
        elseif field_number == 3
            peak_bytes = PB.decode(d, Int64)
        elseif field_number == 4
            live_bytes = PB.decode(d, Int64)
        elseif field_number == 6
            PB.decode!(d, allocation_records)
        elseif field_number == 5
            allocator_bytes_in_use = PB.decode(d, Int64)
        else
            PB.skip(d, wire_type)
        end
    end
    return AllocatorMemoryUsed(allocator_name, total_bytes, peak_bytes, live_bytes, allocation_records[], allocator_bytes_in_use)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::AllocatorMemoryUsed)
    initpos = position(e.io)
    !isempty(x.allocator_name) && PB.encode(e, 1, x.allocator_name)
    x.total_bytes != zero(Int64) && PB.encode(e, 2, x.total_bytes)
    x.peak_bytes != zero(Int64) && PB.encode(e, 3, x.peak_bytes)
    x.live_bytes != zero(Int64) && PB.encode(e, 4, x.live_bytes)
    !isempty(x.allocation_records) && PB.encode(e, 6, x.allocation_records)
    x.allocator_bytes_in_use != zero(Int64) && PB.encode(e, 5, x.allocator_bytes_in_use)
    return position(e.io) - initpos
end
function PB._encoded_size(x::AllocatorMemoryUsed)
    encoded_size = 0
    !isempty(x.allocator_name) && (encoded_size += PB._encoded_size(x.allocator_name, 1))
    x.total_bytes != zero(Int64) && (encoded_size += PB._encoded_size(x.total_bytes, 2))
    x.peak_bytes != zero(Int64) && (encoded_size += PB._encoded_size(x.peak_bytes, 3))
    x.live_bytes != zero(Int64) && (encoded_size += PB._encoded_size(x.live_bytes, 4))
    !isempty(x.allocation_records) && (encoded_size += PB._encoded_size(x.allocation_records, 6))
    x.allocator_bytes_in_use != zero(Int64) && (encoded_size += PB._encoded_size(x.allocator_bytes_in_use, 5))
    return encoded_size
end

struct NodeExecStats
    node_name::String
    all_start_micros::Int64
    op_start_rel_micros::Int64
    op_end_rel_micros::Int64
    all_end_rel_micros::Int64
    memory::Vector{AllocatorMemoryUsed}
    output::Vector{NodeOutput}
    timeline_label::String
    scheduled_micros::Int64
    thread_id::UInt32
    referenced_tensor::Vector{AllocationDescription}
    memory_stats::Union{Nothing,MemoryStats}
    all_start_nanos::Int64
    op_start_rel_nanos::Int64
    op_end_rel_nanos::Int64
    all_end_rel_nanos::Int64
    scheduled_nanos::Int64
end
PB.default_values(::Type{NodeExecStats}) = (;node_name = "", all_start_micros = zero(Int64), op_start_rel_micros = zero(Int64), op_end_rel_micros = zero(Int64), all_end_rel_micros = zero(Int64), memory = Vector{AllocatorMemoryUsed}(), output = Vector{NodeOutput}(), timeline_label = "", scheduled_micros = zero(Int64), thread_id = zero(UInt32), referenced_tensor = Vector{AllocationDescription}(), memory_stats = nothing, all_start_nanos = zero(Int64), op_start_rel_nanos = zero(Int64), op_end_rel_nanos = zero(Int64), all_end_rel_nanos = zero(Int64), scheduled_nanos = zero(Int64))
PB.field_numbers(::Type{NodeExecStats}) = (;node_name = 1, all_start_micros = 2, op_start_rel_micros = 3, op_end_rel_micros = 4, all_end_rel_micros = 5, memory = 6, output = 7, timeline_label = 8, scheduled_micros = 9, thread_id = 10, referenced_tensor = 11, memory_stats = 12, all_start_nanos = 13, op_start_rel_nanos = 14, op_end_rel_nanos = 15, all_end_rel_nanos = 16, scheduled_nanos = 17)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:NodeExecStats})
    node_name = ""
    all_start_micros = zero(Int64)
    op_start_rel_micros = zero(Int64)
    op_end_rel_micros = zero(Int64)
    all_end_rel_micros = zero(Int64)
    memory = PB.BufferedVector{AllocatorMemoryUsed}()
    output = PB.BufferedVector{NodeOutput}()
    timeline_label = ""
    scheduled_micros = zero(Int64)
    thread_id = zero(UInt32)
    referenced_tensor = PB.BufferedVector{AllocationDescription}()
    memory_stats = Ref{Union{Nothing,MemoryStats}}(nothing)
    all_start_nanos = zero(Int64)
    op_start_rel_nanos = zero(Int64)
    op_end_rel_nanos = zero(Int64)
    all_end_rel_nanos = zero(Int64)
    scheduled_nanos = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            node_name = PB.decode(d, String)
        elseif field_number == 2
            all_start_micros = PB.decode(d, Int64)
        elseif field_number == 3
            op_start_rel_micros = PB.decode(d, Int64)
        elseif field_number == 4
            op_end_rel_micros = PB.decode(d, Int64)
        elseif field_number == 5
            all_end_rel_micros = PB.decode(d, Int64)
        elseif field_number == 6
            PB.decode!(d, memory)
        elseif field_number == 7
            PB.decode!(d, output)
        elseif field_number == 8
            timeline_label = PB.decode(d, String)
        elseif field_number == 9
            scheduled_micros = PB.decode(d, Int64)
        elseif field_number == 10
            thread_id = PB.decode(d, UInt32)
        elseif field_number == 11
            PB.decode!(d, referenced_tensor)
        elseif field_number == 12
            PB.decode!(d, memory_stats)
        elseif field_number == 13
            all_start_nanos = PB.decode(d, Int64)
        elseif field_number == 14
            op_start_rel_nanos = PB.decode(d, Int64)
        elseif field_number == 15
            op_end_rel_nanos = PB.decode(d, Int64)
        elseif field_number == 16
            all_end_rel_nanos = PB.decode(d, Int64)
        elseif field_number == 17
            scheduled_nanos = PB.decode(d, Int64)
        else
            PB.skip(d, wire_type)
        end
    end
    return NodeExecStats(node_name, all_start_micros, op_start_rel_micros, op_end_rel_micros, all_end_rel_micros, memory[], output[], timeline_label, scheduled_micros, thread_id, referenced_tensor[], memory_stats[], all_start_nanos, op_start_rel_nanos, op_end_rel_nanos, all_end_rel_nanos, scheduled_nanos)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::NodeExecStats)
    initpos = position(e.io)
    !isempty(x.node_name) && PB.encode(e, 1, x.node_name)
    x.all_start_micros != zero(Int64) && PB.encode(e, 2, x.all_start_micros)
    x.op_start_rel_micros != zero(Int64) && PB.encode(e, 3, x.op_start_rel_micros)
    x.op_end_rel_micros != zero(Int64) && PB.encode(e, 4, x.op_end_rel_micros)
    x.all_end_rel_micros != zero(Int64) && PB.encode(e, 5, x.all_end_rel_micros)
    !isempty(x.memory) && PB.encode(e, 6, x.memory)
    !isempty(x.output) && PB.encode(e, 7, x.output)
    !isempty(x.timeline_label) && PB.encode(e, 8, x.timeline_label)
    x.scheduled_micros != zero(Int64) && PB.encode(e, 9, x.scheduled_micros)
    x.thread_id != zero(UInt32) && PB.encode(e, 10, x.thread_id)
    !isempty(x.referenced_tensor) && PB.encode(e, 11, x.referenced_tensor)
    !isnothing(x.memory_stats) && PB.encode(e, 12, x.memory_stats)
    x.all_start_nanos != zero(Int64) && PB.encode(e, 13, x.all_start_nanos)
    x.op_start_rel_nanos != zero(Int64) && PB.encode(e, 14, x.op_start_rel_nanos)
    x.op_end_rel_nanos != zero(Int64) && PB.encode(e, 15, x.op_end_rel_nanos)
    x.all_end_rel_nanos != zero(Int64) && PB.encode(e, 16, x.all_end_rel_nanos)
    x.scheduled_nanos != zero(Int64) && PB.encode(e, 17, x.scheduled_nanos)
    return position(e.io) - initpos
end
function PB._encoded_size(x::NodeExecStats)
    encoded_size = 0
    !isempty(x.node_name) && (encoded_size += PB._encoded_size(x.node_name, 1))
    x.all_start_micros != zero(Int64) && (encoded_size += PB._encoded_size(x.all_start_micros, 2))
    x.op_start_rel_micros != zero(Int64) && (encoded_size += PB._encoded_size(x.op_start_rel_micros, 3))
    x.op_end_rel_micros != zero(Int64) && (encoded_size += PB._encoded_size(x.op_end_rel_micros, 4))
    x.all_end_rel_micros != zero(Int64) && (encoded_size += PB._encoded_size(x.all_end_rel_micros, 5))
    !isempty(x.memory) && (encoded_size += PB._encoded_size(x.memory, 6))
    !isempty(x.output) && (encoded_size += PB._encoded_size(x.output, 7))
    !isempty(x.timeline_label) && (encoded_size += PB._encoded_size(x.timeline_label, 8))
    x.scheduled_micros != zero(Int64) && (encoded_size += PB._encoded_size(x.scheduled_micros, 9))
    x.thread_id != zero(UInt32) && (encoded_size += PB._encoded_size(x.thread_id, 10))
    !isempty(x.referenced_tensor) && (encoded_size += PB._encoded_size(x.referenced_tensor, 11))
    !isnothing(x.memory_stats) && (encoded_size += PB._encoded_size(x.memory_stats, 12))
    x.all_start_nanos != zero(Int64) && (encoded_size += PB._encoded_size(x.all_start_nanos, 13))
    x.op_start_rel_nanos != zero(Int64) && (encoded_size += PB._encoded_size(x.op_start_rel_nanos, 14))
    x.op_end_rel_nanos != zero(Int64) && (encoded_size += PB._encoded_size(x.op_end_rel_nanos, 15))
    x.all_end_rel_nanos != zero(Int64) && (encoded_size += PB._encoded_size(x.all_end_rel_nanos, 16))
    x.scheduled_nanos != zero(Int64) && (encoded_size += PB._encoded_size(x.scheduled_nanos, 17))
    return encoded_size
end

struct DeviceStepStats
    device::String
    node_stats::Vector{NodeExecStats}
    thread_names::Dict{UInt32,String}
end
PB.default_values(::Type{DeviceStepStats}) = (;device = "", node_stats = Vector{NodeExecStats}(), thread_names = Dict{UInt32,String}())
PB.field_numbers(::Type{DeviceStepStats}) = (;device = 1, node_stats = 2, thread_names = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DeviceStepStats})
    device = ""
    node_stats = PB.BufferedVector{NodeExecStats}()
    thread_names = Dict{UInt32,String}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            device = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, node_stats)
        elseif field_number == 3
            PB.decode!(d, thread_names)
        else
            PB.skip(d, wire_type)
        end
    end
    return DeviceStepStats(device, node_stats[], thread_names)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DeviceStepStats)
    initpos = position(e.io)
    !isempty(x.device) && PB.encode(e, 1, x.device)
    !isempty(x.node_stats) && PB.encode(e, 2, x.node_stats)
    !isempty(x.thread_names) && PB.encode(e, 3, x.thread_names)
    return position(e.io) - initpos
end
function PB._encoded_size(x::DeviceStepStats)
    encoded_size = 0
    !isempty(x.device) && (encoded_size += PB._encoded_size(x.device, 1))
    !isempty(x.node_stats) && (encoded_size += PB._encoded_size(x.node_stats, 2))
    !isempty(x.thread_names) && (encoded_size += PB._encoded_size(x.thread_names, 3))
    return encoded_size
end

struct StepStats
    dev_stats::Vector{DeviceStepStats}
end
PB.default_values(::Type{StepStats}) = (;dev_stats = Vector{DeviceStepStats}())
PB.field_numbers(::Type{StepStats}) = (;dev_stats = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:StepStats})
    dev_stats = PB.BufferedVector{DeviceStepStats}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, dev_stats)
        else
            PB.skip(d, wire_type)
        end
    end
    return StepStats(dev_stats[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::StepStats)
    initpos = position(e.io)
    !isempty(x.dev_stats) && PB.encode(e, 1, x.dev_stats)
    return position(e.io) - initpos
end
function PB._encoded_size(x::StepStats)
    encoded_size = 0
    !isempty(x.dev_stats) && (encoded_size += PB._encoded_size(x.dev_stats, 1))
    return encoded_size
end