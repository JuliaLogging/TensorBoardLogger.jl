# Autogenerated using ProtoBuf.jl v1.0.11 on 2023-08-09T10:18:18.632
# original file: proto/tensorboard/tensorboard/event.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export var"SessionLog.SessionStatus", WorkerHealth, WatchdogConfig, RequestedExitCode
export SourceMetadata, WorkerShutdownMode, TaggedRunMetadata, var"LogMessage.Level"
export SessionLog, WorkerHeartbeatRequest, LogMessage, Event, WorkerHeartbeatResponse

@enumx var"SessionLog.SessionStatus" STATUS_UNSPECIFIED=0 START=1 STOP=2 CHECKPOINT=3

@enumx WorkerHealth OK=0 RECEIVED_SHUTDOWN_SIGNAL=1 INTERNAL_ERROR=2 SHUTTING_DOWN=3

struct WatchdogConfig
    timeout_ms::Int64
end
PB.default_values(::Type{WatchdogConfig}) = (;timeout_ms = zero(Int64))
PB.field_numbers(::Type{WatchdogConfig}) = (;timeout_ms = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:WatchdogConfig})
    timeout_ms = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            timeout_ms = PB.decode(d, Int64)
        else
            PB.skip(d, wire_type)
        end
    end
    return WatchdogConfig(timeout_ms)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::WatchdogConfig)
    initpos = position(e.io)
    x.timeout_ms != zero(Int64) && PB.encode(e, 1, x.timeout_ms)
    return position(e.io) - initpos
end
function PB._encoded_size(x::WatchdogConfig)
    encoded_size = 0
    x.timeout_ms != zero(Int64) && (encoded_size += PB._encoded_size(x.timeout_ms, 1))
    return encoded_size
end

struct RequestedExitCode
    exit_code::Int32
end
PB.default_values(::Type{RequestedExitCode}) = (;exit_code = zero(Int32))
PB.field_numbers(::Type{RequestedExitCode}) = (;exit_code = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RequestedExitCode})
    exit_code = zero(Int32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            exit_code = PB.decode(d, Int32)
        else
            PB.skip(d, wire_type)
        end
    end
    return RequestedExitCode(exit_code)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RequestedExitCode)
    initpos = position(e.io)
    x.exit_code != zero(Int32) && PB.encode(e, 1, x.exit_code)
    return position(e.io) - initpos
end
function PB._encoded_size(x::RequestedExitCode)
    encoded_size = 0
    x.exit_code != zero(Int32) && (encoded_size += PB._encoded_size(x.exit_code, 1))
    return encoded_size
end

struct SourceMetadata
    writer::String
end
PB.default_values(::Type{SourceMetadata}) = (;writer = "")
PB.field_numbers(::Type{SourceMetadata}) = (;writer = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SourceMetadata})
    writer = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            writer = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return SourceMetadata(writer)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SourceMetadata)
    initpos = position(e.io)
    !isempty(x.writer) && PB.encode(e, 1, x.writer)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SourceMetadata)
    encoded_size = 0
    !isempty(x.writer) && (encoded_size += PB._encoded_size(x.writer, 1))
    return encoded_size
end

@enumx WorkerShutdownMode DEFAULT=0 NOT_CONFIGURED=1 WAIT_FOR_COORDINATOR=2 SHUTDOWN_AFTER_TIMEOUT=3

struct TaggedRunMetadata
    tag::String
    run_metadata::Vector{UInt8}
end
PB.default_values(::Type{TaggedRunMetadata}) = (;tag = "", run_metadata = UInt8[])
PB.field_numbers(::Type{TaggedRunMetadata}) = (;tag = 1, run_metadata = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TaggedRunMetadata})
    tag = ""
    run_metadata = UInt8[]
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            tag = PB.decode(d, String)
        elseif field_number == 2
            run_metadata = PB.decode(d, Vector{UInt8})
        else
            PB.skip(d, wire_type)
        end
    end
    return TaggedRunMetadata(tag, run_metadata)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TaggedRunMetadata)
    initpos = position(e.io)
    !isempty(x.tag) && PB.encode(e, 1, x.tag)
    !isempty(x.run_metadata) && PB.encode(e, 2, x.run_metadata)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TaggedRunMetadata)
    encoded_size = 0
    !isempty(x.tag) && (encoded_size += PB._encoded_size(x.tag, 1))
    !isempty(x.run_metadata) && (encoded_size += PB._encoded_size(x.run_metadata, 2))
    return encoded_size
end

@enumx var"LogMessage.Level" UNKNOWN=0 DEBUGGING=10 INFO=20 WARN=30 ERROR=40 FATAL=50
Base.depwarn("`var\"LogMessage.Level\"` is deprecated.", ((Base.Core).Typeof(var"LogMessage.Level")).name.mt.name)

struct SessionLog
    status::var"SessionLog.SessionStatus".T
    checkpoint_path::String
    msg::String
end
PB.default_values(::Type{SessionLog}) = (;status = var"SessionLog.SessionStatus".STATUS_UNSPECIFIED, checkpoint_path = "", msg = "")
PB.field_numbers(::Type{SessionLog}) = (;status = 1, checkpoint_path = 2, msg = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SessionLog})
    status = var"SessionLog.SessionStatus".STATUS_UNSPECIFIED
    checkpoint_path = ""
    msg = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            status = PB.decode(d, var"SessionLog.SessionStatus".T)
        elseif field_number == 2
            checkpoint_path = PB.decode(d, String)
        elseif field_number == 3
            msg = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return SessionLog(status, checkpoint_path, msg)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SessionLog)
    initpos = position(e.io)
    x.status != var"SessionLog.SessionStatus".STATUS_UNSPECIFIED && PB.encode(e, 1, x.status)
    !isempty(x.checkpoint_path) && PB.encode(e, 2, x.checkpoint_path)
    !isempty(x.msg) && PB.encode(e, 3, x.msg)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SessionLog)
    encoded_size = 0
    x.status != var"SessionLog.SessionStatus".STATUS_UNSPECIFIED && (encoded_size += PB._encoded_size(x.status, 1))
    !isempty(x.checkpoint_path) && (encoded_size += PB._encoded_size(x.checkpoint_path, 2))
    !isempty(x.msg) && (encoded_size += PB._encoded_size(x.msg, 3))
    return encoded_size
end

struct WorkerHeartbeatRequest
    shutdown_mode::WorkerShutdownMode.T
    watchdog_config::Union{Nothing,WatchdogConfig}
    exit_code::Union{Nothing,RequestedExitCode}
end
PB.default_values(::Type{WorkerHeartbeatRequest}) = (;shutdown_mode = WorkerShutdownMode.DEFAULT, watchdog_config = nothing, exit_code = nothing)
PB.field_numbers(::Type{WorkerHeartbeatRequest}) = (;shutdown_mode = 1, watchdog_config = 2, exit_code = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:WorkerHeartbeatRequest})
    shutdown_mode = WorkerShutdownMode.DEFAULT
    watchdog_config = Ref{Union{Nothing,WatchdogConfig}}(nothing)
    exit_code = Ref{Union{Nothing,RequestedExitCode}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            shutdown_mode = PB.decode(d, WorkerShutdownMode.T)
        elseif field_number == 2
            PB.decode!(d, watchdog_config)
        elseif field_number == 3
            PB.decode!(d, exit_code)
        else
            PB.skip(d, wire_type)
        end
    end
    return WorkerHeartbeatRequest(shutdown_mode, watchdog_config[], exit_code[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::WorkerHeartbeatRequest)
    initpos = position(e.io)
    x.shutdown_mode != WorkerShutdownMode.DEFAULT && PB.encode(e, 1, x.shutdown_mode)
    !isnothing(x.watchdog_config) && PB.encode(e, 2, x.watchdog_config)
    !isnothing(x.exit_code) && PB.encode(e, 3, x.exit_code)
    return position(e.io) - initpos
end
function PB._encoded_size(x::WorkerHeartbeatRequest)
    encoded_size = 0
    x.shutdown_mode != WorkerShutdownMode.DEFAULT && (encoded_size += PB._encoded_size(x.shutdown_mode, 1))
    !isnothing(x.watchdog_config) && (encoded_size += PB._encoded_size(x.watchdog_config, 2))
    !isnothing(x.exit_code) && (encoded_size += PB._encoded_size(x.exit_code, 3))
    return encoded_size
end

struct LogMessage
    level::var"LogMessage.Level".T
    message::String
end
Base.depwarn("`LogMessage` is deprecated.", ((Base.Core).Typeof(LogMessage)).name.mt.name)
PB.default_values(::Type{LogMessage}) = (;level = var"LogMessage.Level".UNKNOWN, message = "")
PB.field_numbers(::Type{LogMessage}) = (;level = 1, message = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LogMessage})
    level = var"LogMessage.Level".UNKNOWN
    message = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            level = PB.decode(d, var"LogMessage.Level".T)
        elseif field_number == 2
            message = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return LogMessage(level, message)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LogMessage)
    initpos = position(e.io)
    x.level != var"LogMessage.Level".UNKNOWN && PB.encode(e, 1, x.level)
    !isempty(x.message) && PB.encode(e, 2, x.message)
    return position(e.io) - initpos
end
function PB._encoded_size(x::LogMessage)
    encoded_size = 0
    x.level != var"LogMessage.Level".UNKNOWN && (encoded_size += PB._encoded_size(x.level, 1))
    !isempty(x.message) && (encoded_size += PB._encoded_size(x.message, 2))
    return encoded_size
end

struct Event
    wall_time::Float64
    step::Int64
    what::Union{Nothing,OneOf{<:Union{String,Vector{UInt8},Summary,LogMessage,SessionLog,TaggedRunMetadata}}}
    source_metadata::Union{Nothing,SourceMetadata}
end
PB.oneof_field_types(::Type{Event}) = (;
    what = (;file_version=String, graph_def=Vector{UInt8}, summary=Summary, log_message=LogMessage, session_log=SessionLog, tagged_run_metadata=TaggedRunMetadata, meta_graph_def=Vector{UInt8}),
)
PB.default_values(::Type{Event}) = (;wall_time = zero(Float64), step = zero(Int64), file_version = "", graph_def = UInt8[], summary = nothing, log_message = nothing, session_log = nothing, tagged_run_metadata = nothing, meta_graph_def = UInt8[], source_metadata = nothing)
PB.field_numbers(::Type{Event}) = (;wall_time = 1, step = 2, file_version = 3, graph_def = 4, summary = 5, log_message = 6, session_log = 7, tagged_run_metadata = 8, meta_graph_def = 9, source_metadata = 10)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Event})
    wall_time = zero(Float64)
    step = zero(Int64)
    what = nothing
    source_metadata = Ref{Union{Nothing,SourceMetadata}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            wall_time = PB.decode(d, Float64)
        elseif field_number == 2
            step = PB.decode(d, Int64)
        elseif field_number == 3
            what = OneOf(:file_version, PB.decode(d, String))
        elseif field_number == 4
            what = OneOf(:graph_def, PB.decode(d, Vector{UInt8}))
        elseif field_number == 5
            what = OneOf(:summary, PB.decode(d, Ref{Summary}))
        elseif field_number == 6
            what = OneOf(:log_message, PB.decode(d, Ref{LogMessage}))
        elseif field_number == 7
            what = OneOf(:session_log, PB.decode(d, Ref{SessionLog}))
        elseif field_number == 8
            what = OneOf(:tagged_run_metadata, PB.decode(d, Ref{TaggedRunMetadata}))
        elseif field_number == 9
            what = OneOf(:meta_graph_def, PB.decode(d, Vector{UInt8}))
        elseif field_number == 10
            PB.decode!(d, source_metadata)
        else
            PB.skip(d, wire_type)
        end
    end
    return Event(wall_time, step, what, source_metadata[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Event)
    initpos = position(e.io)
    x.wall_time != zero(Float64) && PB.encode(e, 1, x.wall_time)
    x.step != zero(Int64) && PB.encode(e, 2, x.step)
    if isnothing(x.what);
    elseif x.what.name === :file_version
        PB.encode(e, 3, x.what[]::String)
    elseif x.what.name === :graph_def
        PB.encode(e, 4, x.what[]::Vector{UInt8})
    elseif x.what.name === :summary
        PB.encode(e, 5, x.what[]::Summary)
    elseif x.what.name === :log_message
        PB.encode(e, 6, x.what[]::LogMessage)
    elseif x.what.name === :session_log
        PB.encode(e, 7, x.what[]::SessionLog)
    elseif x.what.name === :tagged_run_metadata
        PB.encode(e, 8, x.what[]::TaggedRunMetadata)
    elseif x.what.name === :meta_graph_def
        PB.encode(e, 9, x.what[]::Vector{UInt8})
    end
    !isnothing(x.source_metadata) && PB.encode(e, 10, x.source_metadata)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Event)
    encoded_size = 0
    x.wall_time != zero(Float64) && (encoded_size += PB._encoded_size(x.wall_time, 1))
    x.step != zero(Int64) && (encoded_size += PB._encoded_size(x.step, 2))
    if isnothing(x.what);
    elseif x.what.name === :file_version
        encoded_size += PB._encoded_size(x.what[]::String, 3)
    elseif x.what.name === :graph_def
        encoded_size += PB._encoded_size(x.what[]::Vector{UInt8}, 4)
    elseif x.what.name === :summary
        encoded_size += PB._encoded_size(x.what[]::Summary, 5)
    elseif x.what.name === :log_message
        encoded_size += PB._encoded_size(x.what[]::LogMessage, 6)
    elseif x.what.name === :session_log
        encoded_size += PB._encoded_size(x.what[]::SessionLog, 7)
    elseif x.what.name === :tagged_run_metadata
        encoded_size += PB._encoded_size(x.what[]::TaggedRunMetadata, 8)
    elseif x.what.name === :meta_graph_def
        encoded_size += PB._encoded_size(x.what[]::Vector{UInt8}, 9)
    end
    !isnothing(x.source_metadata) && (encoded_size += PB._encoded_size(x.source_metadata, 10))
    return encoded_size
end

struct WorkerHeartbeatResponse
    health_status::WorkerHealth.T
    worker_log::Vector{Event}
    hostname::String
end
PB.default_values(::Type{WorkerHeartbeatResponse}) = (;health_status = WorkerHealth.OK, worker_log = Vector{Event}(), hostname = "")
PB.field_numbers(::Type{WorkerHeartbeatResponse}) = (;health_status = 1, worker_log = 2, hostname = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:WorkerHeartbeatResponse})
    health_status = WorkerHealth.OK
    worker_log = PB.BufferedVector{Event}()
    hostname = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            health_status = PB.decode(d, WorkerHealth.T)
        elseif field_number == 2
            PB.decode!(d, worker_log)
        elseif field_number == 3
            hostname = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return WorkerHeartbeatResponse(health_status, worker_log[], hostname)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::WorkerHeartbeatResponse)
    initpos = position(e.io)
    x.health_status != WorkerHealth.OK && PB.encode(e, 1, x.health_status)
    !isempty(x.worker_log) && PB.encode(e, 2, x.worker_log)
    !isempty(x.hostname) && PB.encode(e, 3, x.hostname)
    return position(e.io) - initpos
end
function PB._encoded_size(x::WorkerHeartbeatResponse)
    encoded_size = 0
    x.health_status != WorkerHealth.OK && (encoded_size += PB._encoded_size(x.health_status, 1))
    !isempty(x.worker_log) && (encoded_size += PB._encoded_size(x.worker_log, 2))
    !isempty(x.hostname) && (encoded_size += PB._encoded_size(x.hostname, 3))
    return encoded_size
end