# Autogenerated using ProtoBuf.jl v1.0.11 on 2023-08-08T14:34:18.320
# original path: protojl/tensorboard/tensorboard/graph_debug_info.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export var"GraphDebugInfo.FileLineCol", var"GraphDebugInfo.StackTrace", GraphDebugInfo

struct var"GraphDebugInfo.FileLineCol"
    file_index::Int32
    line::Int32
    col::Int32
    func::String
    code::String
end
PB.default_values(::Type{var"GraphDebugInfo.FileLineCol"}) = (;file_index = zero(Int32), line = zero(Int32), col = zero(Int32), func = "", code = "")
PB.field_numbers(::Type{var"GraphDebugInfo.FileLineCol"}) = (;file_index = 1, line = 2, col = 3, func = 4, code = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"GraphDebugInfo.FileLineCol"})
    file_index = zero(Int32)
    line = zero(Int32)
    col = zero(Int32)
    func = ""
    code = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            file_index = PB.decode(d, Int32)
        elseif field_number == 2
            line = PB.decode(d, Int32)
        elseif field_number == 3
            col = PB.decode(d, Int32)
        elseif field_number == 4
            func = PB.decode(d, String)
        elseif field_number == 5
            code = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"GraphDebugInfo.FileLineCol"(file_index, line, col, func, code)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"GraphDebugInfo.FileLineCol")
    initpos = position(e.io)
    x.file_index != zero(Int32) && PB.encode(e, 1, x.file_index)
    x.line != zero(Int32) && PB.encode(e, 2, x.line)
    x.col != zero(Int32) && PB.encode(e, 3, x.col)
    !isempty(x.func) && PB.encode(e, 4, x.func)
    !isempty(x.code) && PB.encode(e, 5, x.code)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"GraphDebugInfo.FileLineCol")
    encoded_size = 0
    x.file_index != zero(Int32) && (encoded_size += PB._encoded_size(x.file_index, 1))
    x.line != zero(Int32) && (encoded_size += PB._encoded_size(x.line, 2))
    x.col != zero(Int32) && (encoded_size += PB._encoded_size(x.col, 3))
    !isempty(x.func) && (encoded_size += PB._encoded_size(x.func, 4))
    !isempty(x.code) && (encoded_size += PB._encoded_size(x.code, 5))
    return encoded_size
end

struct var"GraphDebugInfo.StackTrace"
    file_line_cols::Vector{var"GraphDebugInfo.FileLineCol"}
end
PB.default_values(::Type{var"GraphDebugInfo.StackTrace"}) = (;file_line_cols = Vector{var"GraphDebugInfo.FileLineCol"}())
PB.field_numbers(::Type{var"GraphDebugInfo.StackTrace"}) = (;file_line_cols = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"GraphDebugInfo.StackTrace"})
    file_line_cols = PB.BufferedVector{var"GraphDebugInfo.FileLineCol"}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, file_line_cols)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"GraphDebugInfo.StackTrace"(file_line_cols[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"GraphDebugInfo.StackTrace")
    initpos = position(e.io)
    !isempty(x.file_line_cols) && PB.encode(e, 1, x.file_line_cols)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"GraphDebugInfo.StackTrace")
    encoded_size = 0
    !isempty(x.file_line_cols) && (encoded_size += PB._encoded_size(x.file_line_cols, 1))
    return encoded_size
end

struct GraphDebugInfo
    files::Vector{String}
    traces::Dict{String,var"GraphDebugInfo.StackTrace"}
end
PB.default_values(::Type{GraphDebugInfo}) = (;files = Vector{String}(), traces = Dict{String,var"GraphDebugInfo.StackTrace"}())
PB.field_numbers(::Type{GraphDebugInfo}) = (;files = 1, traces = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GraphDebugInfo})
    files = PB.BufferedVector{String}()
    traces = Dict{String,var"GraphDebugInfo.StackTrace"}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, files)
        elseif field_number == 2
            PB.decode!(d, traces)
        else
            PB.skip(d, wire_type)
        end
    end
    return GraphDebugInfo(files[], traces)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GraphDebugInfo)
    initpos = position(e.io)
    !isempty(x.files) && PB.encode(e, 1, x.files)
    !isempty(x.traces) && PB.encode(e, 2, x.traces)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GraphDebugInfo)
    encoded_size = 0
    !isempty(x.files) && (encoded_size += PB._encoded_size(x.files, 1))
    !isempty(x.traces) && (encoded_size += PB._encoded_size(x.traces, 2))
    return encoded_size
end