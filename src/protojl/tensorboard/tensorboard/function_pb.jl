# Autogenerated using ProtoBuf.jl v1.0.11 on 2023-08-08T14:37:02.036
# original path: proto/tensorboard/tensorboard/function.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export RegisteredGradient, var"FunctionDef.ArgAttrs", GradientDef, FunctionDef
export FunctionDefLibrary

struct RegisteredGradient
    gradient_func::String
    registered_op_type::String
end
PB.default_values(::Type{RegisteredGradient}) = (;gradient_func = "", registered_op_type = "")
PB.field_numbers(::Type{RegisteredGradient}) = (;gradient_func = 1, registered_op_type = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RegisteredGradient})
    gradient_func = ""
    registered_op_type = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            gradient_func = PB.decode(d, String)
        elseif field_number == 2
            registered_op_type = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return RegisteredGradient(gradient_func, registered_op_type)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RegisteredGradient)
    initpos = position(e.io)
    !isempty(x.gradient_func) && PB.encode(e, 1, x.gradient_func)
    !isempty(x.registered_op_type) && PB.encode(e, 2, x.registered_op_type)
    return position(e.io) - initpos
end
function PB._encoded_size(x::RegisteredGradient)
    encoded_size = 0
    !isempty(x.gradient_func) && (encoded_size += PB._encoded_size(x.gradient_func, 1))
    !isempty(x.registered_op_type) && (encoded_size += PB._encoded_size(x.registered_op_type, 2))
    return encoded_size
end

struct var"FunctionDef.ArgAttrs"
    attr::Dict{String,AttrValue}
end
PB.default_values(::Type{var"FunctionDef.ArgAttrs"}) = (;attr = Dict{String,AttrValue}())
PB.field_numbers(::Type{var"FunctionDef.ArgAttrs"}) = (;attr = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"FunctionDef.ArgAttrs"})
    attr = Dict{String,AttrValue}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, attr)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"FunctionDef.ArgAttrs"(attr)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"FunctionDef.ArgAttrs")
    initpos = position(e.io)
    !isempty(x.attr) && PB.encode(e, 1, x.attr)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"FunctionDef.ArgAttrs")
    encoded_size = 0
    !isempty(x.attr) && (encoded_size += PB._encoded_size(x.attr, 1))
    return encoded_size
end

struct GradientDef
    function_name::String
    gradient_func::String
end
PB.default_values(::Type{GradientDef}) = (;function_name = "", gradient_func = "")
PB.field_numbers(::Type{GradientDef}) = (;function_name = 1, gradient_func = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GradientDef})
    function_name = ""
    gradient_func = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            function_name = PB.decode(d, String)
        elseif field_number == 2
            gradient_func = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return GradientDef(function_name, gradient_func)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GradientDef)
    initpos = position(e.io)
    !isempty(x.function_name) && PB.encode(e, 1, x.function_name)
    !isempty(x.gradient_func) && PB.encode(e, 2, x.gradient_func)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GradientDef)
    encoded_size = 0
    !isempty(x.function_name) && (encoded_size += PB._encoded_size(x.function_name, 1))
    !isempty(x.gradient_func) && (encoded_size += PB._encoded_size(x.gradient_func, 2))
    return encoded_size
end

struct FunctionDef
    signature::Union{Nothing,OpDef}
    attr::Dict{String,AttrValue}
    arg_attr::Dict{UInt32,var"FunctionDef.ArgAttrs"}
    resource_arg_unique_id::Dict{UInt32,UInt32}
    node_def::Vector{NodeDef}
    ret::Dict{String,String}
    control_ret::Dict{String,String}
end
PB.reserved_fields(::Type{FunctionDef}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[2])
PB.default_values(::Type{FunctionDef}) = (;signature = nothing, attr = Dict{String,AttrValue}(), arg_attr = Dict{UInt32,var"FunctionDef.ArgAttrs"}(), resource_arg_unique_id = Dict{UInt32,UInt32}(), node_def = Vector{NodeDef}(), ret = Dict{String,String}(), control_ret = Dict{String,String}())
PB.field_numbers(::Type{FunctionDef}) = (;signature = 1, attr = 5, arg_attr = 7, resource_arg_unique_id = 8, node_def = 3, ret = 4, control_ret = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:FunctionDef})
    signature = Ref{Union{Nothing,OpDef}}(nothing)
    attr = Dict{String,AttrValue}()
    arg_attr = Dict{UInt32,var"FunctionDef.ArgAttrs"}()
    resource_arg_unique_id = Dict{UInt32,UInt32}()
    node_def = PB.BufferedVector{NodeDef}()
    ret = Dict{String,String}()
    control_ret = Dict{String,String}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, signature)
        elseif field_number == 5
            PB.decode!(d, attr)
        elseif field_number == 7
            PB.decode!(d, arg_attr)
        elseif field_number == 8
            PB.decode!(d, resource_arg_unique_id)
        elseif field_number == 3
            PB.decode!(d, node_def)
        elseif field_number == 4
            PB.decode!(d, ret)
        elseif field_number == 6
            PB.decode!(d, control_ret)
        else
            PB.skip(d, wire_type)
        end
    end
    return FunctionDef(signature[], attr, arg_attr, resource_arg_unique_id, node_def[], ret, control_ret)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::FunctionDef)
    initpos = position(e.io)
    !isnothing(x.signature) && PB.encode(e, 1, x.signature)
    !isempty(x.attr) && PB.encode(e, 5, x.attr)
    !isempty(x.arg_attr) && PB.encode(e, 7, x.arg_attr)
    !isempty(x.resource_arg_unique_id) && PB.encode(e, 8, x.resource_arg_unique_id)
    !isempty(x.node_def) && PB.encode(e, 3, x.node_def)
    !isempty(x.ret) && PB.encode(e, 4, x.ret)
    !isempty(x.control_ret) && PB.encode(e, 6, x.control_ret)
    return position(e.io) - initpos
end
function PB._encoded_size(x::FunctionDef)
    encoded_size = 0
    !isnothing(x.signature) && (encoded_size += PB._encoded_size(x.signature, 1))
    !isempty(x.attr) && (encoded_size += PB._encoded_size(x.attr, 5))
    !isempty(x.arg_attr) && (encoded_size += PB._encoded_size(x.arg_attr, 7))
    !isempty(x.resource_arg_unique_id) && (encoded_size += PB._encoded_size(x.resource_arg_unique_id, 8))
    !isempty(x.node_def) && (encoded_size += PB._encoded_size(x.node_def, 3))
    !isempty(x.ret) && (encoded_size += PB._encoded_size(x.ret, 4))
    !isempty(x.control_ret) && (encoded_size += PB._encoded_size(x.control_ret, 6))
    return encoded_size
end

struct FunctionDefLibrary
    var"#function"::Vector{FunctionDef}
    gradient::Vector{GradientDef}
    registered_gradients::Vector{RegisteredGradient}
end
PB.default_values(::Type{FunctionDefLibrary}) = (;var"#function" = Vector{FunctionDef}(), gradient = Vector{GradientDef}(), registered_gradients = Vector{RegisteredGradient}())
PB.field_numbers(::Type{FunctionDefLibrary}) = (;var"#function" = 1, gradient = 2, registered_gradients = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:FunctionDefLibrary})
    var"#function" = PB.BufferedVector{FunctionDef}()
    gradient = PB.BufferedVector{GradientDef}()
    registered_gradients = PB.BufferedVector{RegisteredGradient}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, var"#function")
        elseif field_number == 2
            PB.decode!(d, gradient)
        elseif field_number == 3
            PB.decode!(d, registered_gradients)
        else
            PB.skip(d, wire_type)
        end
    end
    return FunctionDefLibrary(var"#function"[], gradient[], registered_gradients[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::FunctionDefLibrary)
    initpos = position(e.io)
    !isempty(x.var"#function") && PB.encode(e, 1, x.var"#function")
    !isempty(x.gradient) && PB.encode(e, 2, x.gradient)
    !isempty(x.registered_gradients) && PB.encode(e, 3, x.registered_gradients)
    return position(e.io) - initpos
end
function PB._encoded_size(x::FunctionDefLibrary)
    encoded_size = 0
    !isempty(x.var"#function") && (encoded_size += PB._encoded_size(x.var"#function", 1))
    !isempty(x.gradient) && (encoded_size += PB._encoded_size(x.gradient, 2))
    !isempty(x.registered_gradients) && (encoded_size += PB._encoded_size(x.registered_gradients, 3))
    return encoded_size
end