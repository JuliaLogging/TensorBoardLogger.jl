# Autogenerated using ProtoBuf.jl v1.0.11 on 2023-08-08T14:34:18.323
# original path: protojl/tensorboard/tensorboard/summary.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export var"SummaryMetadata.PluginData", DataClass, var"Summary.Audio", var"Summary.Image"
export SummaryDescription, SummaryMetadata, var"Summary.Value", Summary

struct var"SummaryMetadata.PluginData"
    plugin_name::String
    content::Vector{UInt8}
end
PB.default_values(::Type{var"SummaryMetadata.PluginData"}) = (;plugin_name = "", content = UInt8[])
PB.field_numbers(::Type{var"SummaryMetadata.PluginData"}) = (;plugin_name = 1, content = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"SummaryMetadata.PluginData"})
    plugin_name = ""
    content = UInt8[]
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            plugin_name = PB.decode(d, String)
        elseif field_number == 2
            content = PB.decode(d, Vector{UInt8})
        else
            PB.skip(d, wire_type)
        end
    end
    return var"SummaryMetadata.PluginData"(plugin_name, content)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"SummaryMetadata.PluginData")
    initpos = position(e.io)
    !isempty(x.plugin_name) && PB.encode(e, 1, x.plugin_name)
    !isempty(x.content) && PB.encode(e, 2, x.content)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"SummaryMetadata.PluginData")
    encoded_size = 0
    !isempty(x.plugin_name) && (encoded_size += PB._encoded_size(x.plugin_name, 1))
    !isempty(x.content) && (encoded_size += PB._encoded_size(x.content, 2))
    return encoded_size
end

@enumx DataClass DATA_CLASS_UNKNOWN=0 DATA_CLASS_SCALAR=1 DATA_CLASS_TENSOR=2 DATA_CLASS_BLOB_SEQUENCE=3

struct var"Summary.Audio"
    sample_rate::Float32
    num_channels::Int64
    length_frames::Int64
    encoded_audio_string::Vector{UInt8}
    content_type::String
end
PB.default_values(::Type{var"Summary.Audio"}) = (;sample_rate = zero(Float32), num_channels = zero(Int64), length_frames = zero(Int64), encoded_audio_string = UInt8[], content_type = "")
PB.field_numbers(::Type{var"Summary.Audio"}) = (;sample_rate = 1, num_channels = 2, length_frames = 3, encoded_audio_string = 4, content_type = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"Summary.Audio"})
    sample_rate = zero(Float32)
    num_channels = zero(Int64)
    length_frames = zero(Int64)
    encoded_audio_string = UInt8[]
    content_type = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            sample_rate = PB.decode(d, Float32)
        elseif field_number == 2
            num_channels = PB.decode(d, Int64)
        elseif field_number == 3
            length_frames = PB.decode(d, Int64)
        elseif field_number == 4
            encoded_audio_string = PB.decode(d, Vector{UInt8})
        elseif field_number == 5
            content_type = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"Summary.Audio"(sample_rate, num_channels, length_frames, encoded_audio_string, content_type)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"Summary.Audio")
    initpos = position(e.io)
    x.sample_rate != zero(Float32) && PB.encode(e, 1, x.sample_rate)
    x.num_channels != zero(Int64) && PB.encode(e, 2, x.num_channels)
    x.length_frames != zero(Int64) && PB.encode(e, 3, x.length_frames)
    !isempty(x.encoded_audio_string) && PB.encode(e, 4, x.encoded_audio_string)
    !isempty(x.content_type) && PB.encode(e, 5, x.content_type)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"Summary.Audio")
    encoded_size = 0
    x.sample_rate != zero(Float32) && (encoded_size += PB._encoded_size(x.sample_rate, 1))
    x.num_channels != zero(Int64) && (encoded_size += PB._encoded_size(x.num_channels, 2))
    x.length_frames != zero(Int64) && (encoded_size += PB._encoded_size(x.length_frames, 3))
    !isempty(x.encoded_audio_string) && (encoded_size += PB._encoded_size(x.encoded_audio_string, 4))
    !isempty(x.content_type) && (encoded_size += PB._encoded_size(x.content_type, 5))
    return encoded_size
end

struct var"Summary.Image"
    height::Int32
    width::Int32
    colorspace::Int32
    encoded_image_string::Vector{UInt8}
end
PB.default_values(::Type{var"Summary.Image"}) = (;height = zero(Int32), width = zero(Int32), colorspace = zero(Int32), encoded_image_string = UInt8[])
PB.field_numbers(::Type{var"Summary.Image"}) = (;height = 1, width = 2, colorspace = 3, encoded_image_string = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"Summary.Image"})
    height = zero(Int32)
    width = zero(Int32)
    colorspace = zero(Int32)
    encoded_image_string = UInt8[]
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            height = PB.decode(d, Int32)
        elseif field_number == 2
            width = PB.decode(d, Int32)
        elseif field_number == 3
            colorspace = PB.decode(d, Int32)
        elseif field_number == 4
            encoded_image_string = PB.decode(d, Vector{UInt8})
        else
            PB.skip(d, wire_type)
        end
    end
    return var"Summary.Image"(height, width, colorspace, encoded_image_string)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"Summary.Image")
    initpos = position(e.io)
    x.height != zero(Int32) && PB.encode(e, 1, x.height)
    x.width != zero(Int32) && PB.encode(e, 2, x.width)
    x.colorspace != zero(Int32) && PB.encode(e, 3, x.colorspace)
    !isempty(x.encoded_image_string) && PB.encode(e, 4, x.encoded_image_string)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"Summary.Image")
    encoded_size = 0
    x.height != zero(Int32) && (encoded_size += PB._encoded_size(x.height, 1))
    x.width != zero(Int32) && (encoded_size += PB._encoded_size(x.width, 2))
    x.colorspace != zero(Int32) && (encoded_size += PB._encoded_size(x.colorspace, 3))
    !isempty(x.encoded_image_string) && (encoded_size += PB._encoded_size(x.encoded_image_string, 4))
    return encoded_size
end

struct SummaryDescription
    type_hint::String
end
PB.default_values(::Type{SummaryDescription}) = (;type_hint = "")
PB.field_numbers(::Type{SummaryDescription}) = (;type_hint = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SummaryDescription})
    type_hint = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            type_hint = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return SummaryDescription(type_hint)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SummaryDescription)
    initpos = position(e.io)
    !isempty(x.type_hint) && PB.encode(e, 1, x.type_hint)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SummaryDescription)
    encoded_size = 0
    !isempty(x.type_hint) && (encoded_size += PB._encoded_size(x.type_hint, 1))
    return encoded_size
end

struct SummaryMetadata
    plugin_data::Union{Nothing,var"SummaryMetadata.PluginData"}
    display_name::String
    summary_description::String
    data_class::DataClass.T
end
PB.default_values(::Type{SummaryMetadata}) = (;plugin_data = nothing, display_name = "", summary_description = "", data_class = DataClass.DATA_CLASS_UNKNOWN)
PB.field_numbers(::Type{SummaryMetadata}) = (;plugin_data = 1, display_name = 2, summary_description = 3, data_class = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SummaryMetadata})
    plugin_data = Ref{Union{Nothing,var"SummaryMetadata.PluginData"}}(nothing)
    display_name = ""
    summary_description = ""
    data_class = DataClass.DATA_CLASS_UNKNOWN
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, plugin_data)
        elseif field_number == 2
            display_name = PB.decode(d, String)
        elseif field_number == 3
            summary_description = PB.decode(d, String)
        elseif field_number == 4
            data_class = PB.decode(d, DataClass.T)
        else
            PB.skip(d, wire_type)
        end
    end
    return SummaryMetadata(plugin_data[], display_name, summary_description, data_class)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SummaryMetadata)
    initpos = position(e.io)
    !isnothing(x.plugin_data) && PB.encode(e, 1, x.plugin_data)
    !isempty(x.display_name) && PB.encode(e, 2, x.display_name)
    !isempty(x.summary_description) && PB.encode(e, 3, x.summary_description)
    x.data_class != DataClass.DATA_CLASS_UNKNOWN && PB.encode(e, 4, x.data_class)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SummaryMetadata)
    encoded_size = 0
    !isnothing(x.plugin_data) && (encoded_size += PB._encoded_size(x.plugin_data, 1))
    !isempty(x.display_name) && (encoded_size += PB._encoded_size(x.display_name, 2))
    !isempty(x.summary_description) && (encoded_size += PB._encoded_size(x.summary_description, 3))
    x.data_class != DataClass.DATA_CLASS_UNKNOWN && (encoded_size += PB._encoded_size(x.data_class, 4))
    return encoded_size
end

struct var"Summary.Value"
    node_name::String
    tag::String
    metadata::Union{Nothing,SummaryMetadata}
    value::Union{Nothing,OneOf{<:Union{Float32,Vector{UInt8},var"Summary.Image",HistogramProto,var"Summary.Audio",TensorProto}}}
end
PB.oneof_field_types(::Type{var"Summary.Value"}) = (;
    value = (;simple_value=Float32, obsolete_old_style_histogram=Vector{UInt8}, image=var"Summary.Image", histo=HistogramProto, audio=var"Summary.Audio", tensor=TensorProto),
)
PB.default_values(::Type{var"Summary.Value"}) = (;node_name = "", tag = "", metadata = nothing, simple_value = zero(Float32), obsolete_old_style_histogram = UInt8[], image = nothing, histo = nothing, audio = nothing, tensor = nothing)
PB.field_numbers(::Type{var"Summary.Value"}) = (;node_name = 7, tag = 1, metadata = 9, simple_value = 2, obsolete_old_style_histogram = 3, image = 4, histo = 5, audio = 6, tensor = 8)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"Summary.Value"})
    node_name = ""
    tag = ""
    metadata = Ref{Union{Nothing,SummaryMetadata}}(nothing)
    value = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 7
            node_name = PB.decode(d, String)
        elseif field_number == 1
            tag = PB.decode(d, String)
        elseif field_number == 9
            PB.decode!(d, metadata)
        elseif field_number == 2
            value = OneOf(:simple_value, PB.decode(d, Float32))
        elseif field_number == 3
            value = OneOf(:obsolete_old_style_histogram, PB.decode(d, Vector{UInt8}))
        elseif field_number == 4
            value = OneOf(:image, PB.decode(d, Ref{var"Summary.Image"}))
        elseif field_number == 5
            value = OneOf(:histo, PB.decode(d, Ref{HistogramProto}))
        elseif field_number == 6
            value = OneOf(:audio, PB.decode(d, Ref{var"Summary.Audio"}))
        elseif field_number == 8
            value = OneOf(:tensor, PB.decode(d, Ref{TensorProto}))
        else
            PB.skip(d, wire_type)
        end
    end
    return var"Summary.Value"(node_name, tag, metadata[], value)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"Summary.Value")
    initpos = position(e.io)
    !isempty(x.node_name) && PB.encode(e, 7, x.node_name)
    !isempty(x.tag) && PB.encode(e, 1, x.tag)
    !isnothing(x.metadata) && PB.encode(e, 9, x.metadata)
    if isnothing(x.value);
    elseif x.value.name === :simple_value
        PB.encode(e, 2, x.value[]::Float32)
    elseif x.value.name === :obsolete_old_style_histogram
        PB.encode(e, 3, x.value[]::Vector{UInt8})
    elseif x.value.name === :image
        PB.encode(e, 4, x.value[]::var"Summary.Image")
    elseif x.value.name === :histo
        PB.encode(e, 5, x.value[]::HistogramProto)
    elseif x.value.name === :audio
        PB.encode(e, 6, x.value[]::var"Summary.Audio")
    elseif x.value.name === :tensor
        PB.encode(e, 8, x.value[]::TensorProto)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"Summary.Value")
    encoded_size = 0
    !isempty(x.node_name) && (encoded_size += PB._encoded_size(x.node_name, 7))
    !isempty(x.tag) && (encoded_size += PB._encoded_size(x.tag, 1))
    !isnothing(x.metadata) && (encoded_size += PB._encoded_size(x.metadata, 9))
    if isnothing(x.value);
    elseif x.value.name === :simple_value
        encoded_size += PB._encoded_size(x.value[]::Float32, 2)
    elseif x.value.name === :obsolete_old_style_histogram
        encoded_size += PB._encoded_size(x.value[]::Vector{UInt8}, 3)
    elseif x.value.name === :image
        encoded_size += PB._encoded_size(x.value[]::var"Summary.Image", 4)
    elseif x.value.name === :histo
        encoded_size += PB._encoded_size(x.value[]::HistogramProto, 5)
    elseif x.value.name === :audio
        encoded_size += PB._encoded_size(x.value[]::var"Summary.Audio", 6)
    elseif x.value.name === :tensor
        encoded_size += PB._encoded_size(x.value[]::TensorProto, 8)
    end
    return encoded_size
end

struct Summary
    value::Vector{var"Summary.Value"}
end
PB.default_values(::Type{Summary}) = (;value = Vector{var"Summary.Value"}())
PB.field_numbers(::Type{Summary}) = (;value = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Summary})
    value = PB.BufferedVector{var"Summary.Value"}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, value)
        else
            PB.skip(d, wire_type)
        end
    end
    return Summary(value[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Summary)
    initpos = position(e.io)
    !isempty(x.value) && PB.encode(e, 1, x.value)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Summary)
    encoded_size = 0
    !isempty(x.value) && (encoded_size += PB._encoded_size(x.value, 1))
    return encoded_size
end