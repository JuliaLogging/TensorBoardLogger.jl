# Autogenerated using ProtoBuf.jl v1.0.11 on 2023-08-09T10:18:18.292
# original file: proto/tensorboard/tensorboard/variable.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export VariableSynchronization, VariableAggregation, SaveSliceInfoDef, VariableDef

@enumx VariableSynchronization VARIABLE_SYNCHRONIZATION_AUTO=0 VARIABLE_SYNCHRONIZATION_NONE=1 VARIABLE_SYNCHRONIZATION_ON_WRITE=2 VARIABLE_SYNCHRONIZATION_ON_READ=3

@enumx VariableAggregation VARIABLE_AGGREGATION_NONE=0 VARIABLE_AGGREGATION_SUM=1 VARIABLE_AGGREGATION_MEAN=2 VARIABLE_AGGREGATION_ONLY_FIRST_REPLICA=3

struct SaveSliceInfoDef
    full_name::String
    full_shape::Vector{Int64}
    var_offset::Vector{Int64}
    var_shape::Vector{Int64}
end
PB.default_values(::Type{SaveSliceInfoDef}) = (;full_name = "", full_shape = Vector{Int64}(), var_offset = Vector{Int64}(), var_shape = Vector{Int64}())
PB.field_numbers(::Type{SaveSliceInfoDef}) = (;full_name = 1, full_shape = 2, var_offset = 3, var_shape = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SaveSliceInfoDef})
    full_name = ""
    full_shape = PB.BufferedVector{Int64}()
    var_offset = PB.BufferedVector{Int64}()
    var_shape = PB.BufferedVector{Int64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            full_name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, wire_type, full_shape)
        elseif field_number == 3
            PB.decode!(d, wire_type, var_offset)
        elseif field_number == 4
            PB.decode!(d, wire_type, var_shape)
        else
            PB.skip(d, wire_type)
        end
    end
    return SaveSliceInfoDef(full_name, full_shape[], var_offset[], var_shape[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SaveSliceInfoDef)
    initpos = position(e.io)
    !isempty(x.full_name) && PB.encode(e, 1, x.full_name)
    !isempty(x.full_shape) && PB.encode(e, 2, x.full_shape)
    !isempty(x.var_offset) && PB.encode(e, 3, x.var_offset)
    !isempty(x.var_shape) && PB.encode(e, 4, x.var_shape)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SaveSliceInfoDef)
    encoded_size = 0
    !isempty(x.full_name) && (encoded_size += PB._encoded_size(x.full_name, 1))
    !isempty(x.full_shape) && (encoded_size += PB._encoded_size(x.full_shape, 2))
    !isempty(x.var_offset) && (encoded_size += PB._encoded_size(x.var_offset, 3))
    !isempty(x.var_shape) && (encoded_size += PB._encoded_size(x.var_shape, 4))
    return encoded_size
end

struct VariableDef
    variable_name::String
    initial_value_name::String
    initializer_name::String
    snapshot_name::String
    save_slice_info_def::Union{Nothing,SaveSliceInfoDef}
    is_resource::Bool
    trainable::Bool
    synchronization::VariableSynchronization.T
    aggregation::VariableAggregation.T
end
PB.default_values(::Type{VariableDef}) = (;variable_name = "", initial_value_name = "", initializer_name = "", snapshot_name = "", save_slice_info_def = nothing, is_resource = false, trainable = false, synchronization = VariableSynchronization.VARIABLE_SYNCHRONIZATION_AUTO, aggregation = VariableAggregation.VARIABLE_AGGREGATION_NONE)
PB.field_numbers(::Type{VariableDef}) = (;variable_name = 1, initial_value_name = 6, initializer_name = 2, snapshot_name = 3, save_slice_info_def = 4, is_resource = 5, trainable = 7, synchronization = 8, aggregation = 9)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:VariableDef})
    variable_name = ""
    initial_value_name = ""
    initializer_name = ""
    snapshot_name = ""
    save_slice_info_def = Ref{Union{Nothing,SaveSliceInfoDef}}(nothing)
    is_resource = false
    trainable = false
    synchronization = VariableSynchronization.VARIABLE_SYNCHRONIZATION_AUTO
    aggregation = VariableAggregation.VARIABLE_AGGREGATION_NONE
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            variable_name = PB.decode(d, String)
        elseif field_number == 6
            initial_value_name = PB.decode(d, String)
        elseif field_number == 2
            initializer_name = PB.decode(d, String)
        elseif field_number == 3
            snapshot_name = PB.decode(d, String)
        elseif field_number == 4
            PB.decode!(d, save_slice_info_def)
        elseif field_number == 5
            is_resource = PB.decode(d, Bool)
        elseif field_number == 7
            trainable = PB.decode(d, Bool)
        elseif field_number == 8
            synchronization = PB.decode(d, VariableSynchronization.T)
        elseif field_number == 9
            aggregation = PB.decode(d, VariableAggregation.T)
        else
            PB.skip(d, wire_type)
        end
    end
    return VariableDef(variable_name, initial_value_name, initializer_name, snapshot_name, save_slice_info_def[], is_resource, trainable, synchronization, aggregation)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::VariableDef)
    initpos = position(e.io)
    !isempty(x.variable_name) && PB.encode(e, 1, x.variable_name)
    !isempty(x.initial_value_name) && PB.encode(e, 6, x.initial_value_name)
    !isempty(x.initializer_name) && PB.encode(e, 2, x.initializer_name)
    !isempty(x.snapshot_name) && PB.encode(e, 3, x.snapshot_name)
    !isnothing(x.save_slice_info_def) && PB.encode(e, 4, x.save_slice_info_def)
    x.is_resource != false && PB.encode(e, 5, x.is_resource)
    x.trainable != false && PB.encode(e, 7, x.trainable)
    x.synchronization != VariableSynchronization.VARIABLE_SYNCHRONIZATION_AUTO && PB.encode(e, 8, x.synchronization)
    x.aggregation != VariableAggregation.VARIABLE_AGGREGATION_NONE && PB.encode(e, 9, x.aggregation)
    return position(e.io) - initpos
end
function PB._encoded_size(x::VariableDef)
    encoded_size = 0
    !isempty(x.variable_name) && (encoded_size += PB._encoded_size(x.variable_name, 1))
    !isempty(x.initial_value_name) && (encoded_size += PB._encoded_size(x.initial_value_name, 6))
    !isempty(x.initializer_name) && (encoded_size += PB._encoded_size(x.initializer_name, 2))
    !isempty(x.snapshot_name) && (encoded_size += PB._encoded_size(x.snapshot_name, 3))
    !isnothing(x.save_slice_info_def) && (encoded_size += PB._encoded_size(x.save_slice_info_def, 4))
    x.is_resource != false && (encoded_size += PB._encoded_size(x.is_resource, 5))
    x.trainable != false && (encoded_size += PB._encoded_size(x.trainable, 7))
    x.synchronization != VariableSynchronization.VARIABLE_SYNCHRONIZATION_AUTO && (encoded_size += PB._encoded_size(x.synchronization, 8))
    x.aggregation != VariableAggregation.VARIABLE_AGGREGATION_NONE && (encoded_size += PB._encoded_size(x.aggregation, 9))
    return encoded_size
end