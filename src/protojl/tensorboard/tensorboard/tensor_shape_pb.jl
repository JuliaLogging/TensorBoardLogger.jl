# Autogenerated using ProtoBuf.jl v1.0.11 on 2023-08-09T10:18:18.161
# original file: proto/tensorboard/tensorboard/tensor_shape.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export var"TensorShapeProto.Dim", TensorShapeProto

struct var"TensorShapeProto.Dim"
    size::Int64
    name::String
end
PB.default_values(::Type{var"TensorShapeProto.Dim"}) = (;size = zero(Int64), name = "")
PB.field_numbers(::Type{var"TensorShapeProto.Dim"}) = (;size = 1, name = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"TensorShapeProto.Dim"})
    size = zero(Int64)
    name = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            size = PB.decode(d, Int64)
        elseif field_number == 2
            name = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"TensorShapeProto.Dim"(size, name)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"TensorShapeProto.Dim")
    initpos = position(e.io)
    x.size != zero(Int64) && PB.encode(e, 1, x.size)
    !isempty(x.name) && PB.encode(e, 2, x.name)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"TensorShapeProto.Dim")
    encoded_size = 0
    x.size != zero(Int64) && (encoded_size += PB._encoded_size(x.size, 1))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 2))
    return encoded_size
end

struct TensorShapeProto
    dim::Vector{var"TensorShapeProto.Dim"}
    unknown_rank::Bool
end
PB.default_values(::Type{TensorShapeProto}) = (;dim = Vector{var"TensorShapeProto.Dim"}(), unknown_rank = false)
PB.field_numbers(::Type{TensorShapeProto}) = (;dim = 2, unknown_rank = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TensorShapeProto})
    dim = PB.BufferedVector{var"TensorShapeProto.Dim"}()
    unknown_rank = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 2
            PB.decode!(d, dim)
        elseif field_number == 3
            unknown_rank = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return TensorShapeProto(dim[], unknown_rank)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TensorShapeProto)
    initpos = position(e.io)
    !isempty(x.dim) && PB.encode(e, 2, x.dim)
    x.unknown_rank != false && PB.encode(e, 3, x.unknown_rank)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TensorShapeProto)
    encoded_size = 0
    !isempty(x.dim) && (encoded_size += PB._encoded_size(x.dim, 2))
    x.unknown_rank != false && (encoded_size += PB._encoded_size(x.unknown_rank, 3))
    return encoded_size
end