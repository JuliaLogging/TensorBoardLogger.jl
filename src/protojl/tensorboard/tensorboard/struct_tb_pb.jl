# Autogenerated using ProtoBuf.jl v1.0.11 on 2023-08-09T10:18:18.485
# original file: proto/tensorboard/tensorboard/struct_tb.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export NoneValue, var"TypeSpecProto.TypeSpecClass", BoundedTensorSpecProto, TensorSpecProto
export ListValue, TypeSpecProto, NamedTupleValue, PairValue, DictValue, StructuredValue
export TupleValue

# Abstract types to help resolve mutually recursive definitions
abstract type var"##AbstractListValue" end
abstract type var"##AbstractTypeSpecProto" end
abstract type var"##AbstractNamedTupleValue" end
abstract type var"##AbstractPairValue" end
abstract type var"##AbstractDictValue" end
abstract type var"##AbstractStructuredValue" end
abstract type var"##AbstractTupleValue" end


struct NoneValue  end

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:NoneValue})
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        PB.skip(d, wire_type)
    end
    return NoneValue()
end

function PB.encode(e::PB.AbstractProtoEncoder, x::NoneValue)
    initpos = position(e.io)
    return position(e.io) - initpos
end
function PB._encoded_size(x::NoneValue)
    encoded_size = 0
    return encoded_size
end

@enumx var"TypeSpecProto.TypeSpecClass" UNKNOWN=0 SPARSE_TENSOR_SPEC=1 INDEXED_SLICES_SPEC=2 RAGGED_TENSOR_SPEC=3 TENSOR_ARRAY_SPEC=4 DATA_DATASET_SPEC=5 DATA_ITERATOR_SPEC=6 OPTIONAL_SPEC=7 PER_REPLICA_SPEC=8 VARIABLE_SPEC=9 ROW_PARTITION_SPEC=10 REGISTERED_TYPE_SPEC=12 EXTENSION_TYPE_SPEC=13
PB.reserved_fields(::Type{var"TypeSpecProto.TypeSpecClass".T}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[11])

struct BoundedTensorSpecProto
    name::String
    shape::Union{Nothing,TensorShapeProto}
    dtype::var"#DataType".T
    minimum::Union{Nothing,TensorProto}
    maximum::Union{Nothing,TensorProto}
end
PB.default_values(::Type{BoundedTensorSpecProto}) = (;name = "", shape = nothing, dtype = var"#DataType".DT_INVALID, minimum = nothing, maximum = nothing)
PB.field_numbers(::Type{BoundedTensorSpecProto}) = (;name = 1, shape = 2, dtype = 3, minimum = 4, maximum = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:BoundedTensorSpecProto})
    name = ""
    shape = Ref{Union{Nothing,TensorShapeProto}}(nothing)
    dtype = var"#DataType".DT_INVALID
    minimum = Ref{Union{Nothing,TensorProto}}(nothing)
    maximum = Ref{Union{Nothing,TensorProto}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, shape)
        elseif field_number == 3
            dtype = PB.decode(d, var"#DataType".T)
        elseif field_number == 4
            PB.decode!(d, minimum)
        elseif field_number == 5
            PB.decode!(d, maximum)
        else
            PB.skip(d, wire_type)
        end
    end
    return BoundedTensorSpecProto(name, shape[], dtype, minimum[], maximum[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::BoundedTensorSpecProto)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isnothing(x.shape) && PB.encode(e, 2, x.shape)
    x.dtype != var"#DataType".DT_INVALID && PB.encode(e, 3, x.dtype)
    !isnothing(x.minimum) && PB.encode(e, 4, x.minimum)
    !isnothing(x.maximum) && PB.encode(e, 5, x.maximum)
    return position(e.io) - initpos
end
function PB._encoded_size(x::BoundedTensorSpecProto)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isnothing(x.shape) && (encoded_size += PB._encoded_size(x.shape, 2))
    x.dtype != var"#DataType".DT_INVALID && (encoded_size += PB._encoded_size(x.dtype, 3))
    !isnothing(x.minimum) && (encoded_size += PB._encoded_size(x.minimum, 4))
    !isnothing(x.maximum) && (encoded_size += PB._encoded_size(x.maximum, 5))
    return encoded_size
end

struct TensorSpecProto
    name::String
    shape::Union{Nothing,TensorShapeProto}
    dtype::var"#DataType".T
end
PB.default_values(::Type{TensorSpecProto}) = (;name = "", shape = nothing, dtype = var"#DataType".DT_INVALID)
PB.field_numbers(::Type{TensorSpecProto}) = (;name = 1, shape = 2, dtype = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TensorSpecProto})
    name = ""
    shape = Ref{Union{Nothing,TensorShapeProto}}(nothing)
    dtype = var"#DataType".DT_INVALID
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, shape)
        elseif field_number == 3
            dtype = PB.decode(d, var"#DataType".T)
        else
            PB.skip(d, wire_type)
        end
    end
    return TensorSpecProto(name, shape[], dtype)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TensorSpecProto)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isnothing(x.shape) && PB.encode(e, 2, x.shape)
    x.dtype != var"#DataType".DT_INVALID && PB.encode(e, 3, x.dtype)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TensorSpecProto)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isnothing(x.shape) && (encoded_size += PB._encoded_size(x.shape, 2))
    x.dtype != var"#DataType".DT_INVALID && (encoded_size += PB._encoded_size(x.dtype, 3))
    return encoded_size
end

struct ListValue{T1<:Union{Nothing,var"##AbstractStructuredValue"}} <: var"##AbstractListValue"
    values::Vector{T1}
end
PB.default_values(::Type{ListValue}) = (;values = Vector{StructuredValue}())
PB.field_numbers(::Type{ListValue}) = (;values = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ListValue})
    values = PB.BufferedVector{StructuredValue}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, values)
        else
            PB.skip(d, wire_type)
        end
    end
    return ListValue(values[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ListValue)
    initpos = position(e.io)
    !isempty(x.values) && PB.encode(e, 1, x.values)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ListValue)
    encoded_size = 0
    !isempty(x.values) && (encoded_size += PB._encoded_size(x.values, 1))
    return encoded_size
end

struct TypeSpecProto{T1<:Union{Nothing,var"##AbstractStructuredValue"}} <: var"##AbstractTypeSpecProto"
    type_spec_class::var"TypeSpecProto.TypeSpecClass".T
    type_state::T1
    type_spec_class_name::String
    num_flat_components::Int32
end
PB.default_values(::Type{TypeSpecProto}) = (;type_spec_class = var"TypeSpecProto.TypeSpecClass".UNKNOWN, type_state = nothing, type_spec_class_name = "", num_flat_components = zero(Int32))
PB.field_numbers(::Type{TypeSpecProto}) = (;type_spec_class = 1, type_state = 2, type_spec_class_name = 3, num_flat_components = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TypeSpecProto})
    type_spec_class = var"TypeSpecProto.TypeSpecClass".UNKNOWN
    type_state = Ref{Union{Nothing,StructuredValue}}(nothing)
    type_spec_class_name = ""
    num_flat_components = zero(Int32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            type_spec_class = PB.decode(d, var"TypeSpecProto.TypeSpecClass".T)
        elseif field_number == 2
            PB.decode!(d, type_state)
        elseif field_number == 3
            type_spec_class_name = PB.decode(d, String)
        elseif field_number == 4
            num_flat_components = PB.decode(d, Int32)
        else
            PB.skip(d, wire_type)
        end
    end
    return TypeSpecProto(type_spec_class, type_state[], type_spec_class_name, num_flat_components)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TypeSpecProto)
    initpos = position(e.io)
    x.type_spec_class != var"TypeSpecProto.TypeSpecClass".UNKNOWN && PB.encode(e, 1, x.type_spec_class)
    !isnothing(x.type_state) && PB.encode(e, 2, x.type_state)
    !isempty(x.type_spec_class_name) && PB.encode(e, 3, x.type_spec_class_name)
    x.num_flat_components != zero(Int32) && PB.encode(e, 4, x.num_flat_components)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TypeSpecProto)
    encoded_size = 0
    x.type_spec_class != var"TypeSpecProto.TypeSpecClass".UNKNOWN && (encoded_size += PB._encoded_size(x.type_spec_class, 1))
    !isnothing(x.type_state) && (encoded_size += PB._encoded_size(x.type_state, 2))
    !isempty(x.type_spec_class_name) && (encoded_size += PB._encoded_size(x.type_spec_class_name, 3))
    x.num_flat_components != zero(Int32) && (encoded_size += PB._encoded_size(x.num_flat_components, 4))
    return encoded_size
end

struct NamedTupleValue{T1<:Union{Nothing,var"##AbstractPairValue"}} <: var"##AbstractNamedTupleValue"
    name::String
    values::Vector{T1}
end
PB.default_values(::Type{NamedTupleValue}) = (;name = "", values = Vector{PairValue}())
PB.field_numbers(::Type{NamedTupleValue}) = (;name = 1, values = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:NamedTupleValue})
    name = ""
    values = PB.BufferedVector{PairValue}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, values)
        else
            PB.skip(d, wire_type)
        end
    end
    return NamedTupleValue(name, values[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::NamedTupleValue)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.values) && PB.encode(e, 2, x.values)
    return position(e.io) - initpos
end
function PB._encoded_size(x::NamedTupleValue)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.values) && (encoded_size += PB._encoded_size(x.values, 2))
    return encoded_size
end

struct PairValue{T1<:Union{Nothing,var"##AbstractStructuredValue"}} <: var"##AbstractPairValue"
    key::String
    value::T1
end
PB.default_values(::Type{PairValue}) = (;key = "", value = nothing)
PB.field_numbers(::Type{PairValue}) = (;key = 1, value = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:PairValue})
    key = ""
    value = Ref{Union{Nothing,StructuredValue}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            key = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, value)
        else
            PB.skip(d, wire_type)
        end
    end
    return PairValue(key, value[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::PairValue)
    initpos = position(e.io)
    !isempty(x.key) && PB.encode(e, 1, x.key)
    !isnothing(x.value) && PB.encode(e, 2, x.value)
    return position(e.io) - initpos
end
function PB._encoded_size(x::PairValue)
    encoded_size = 0
    !isempty(x.key) && (encoded_size += PB._encoded_size(x.key, 1))
    !isnothing(x.value) && (encoded_size += PB._encoded_size(x.value, 2))
    return encoded_size
end

struct DictValue{T1<:Union{Nothing,var"##AbstractStructuredValue"}} <: var"##AbstractDictValue"
    fields::Dict{String,T1}
end
PB.default_values(::Type{DictValue}) = (;fields = Dict{String,StructuredValue}())
PB.field_numbers(::Type{DictValue}) = (;fields = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DictValue})
    fields = Dict{String,StructuredValue}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, fields)
        else
            PB.skip(d, wire_type)
        end
    end
    return DictValue(fields)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DictValue)
    initpos = position(e.io)
    !isempty(x.fields) && PB.encode(e, 1, x.fields)
    return position(e.io) - initpos
end
function PB._encoded_size(x::DictValue)
    encoded_size = 0
    !isempty(x.fields) && (encoded_size += PB._encoded_size(x.fields, 1))
    return encoded_size
end

struct StructuredValue <: var"##AbstractStructuredValue"
    kind::Union{Nothing,OneOf{<:Union{NoneValue,Float64,Int64,String,Bool,TensorShapeProto,var"#DataType".T,TensorSpecProto,var"##AbstractTypeSpecProto",BoundedTensorSpecProto,var"##AbstractListValue",var"##AbstractTupleValue",var"##AbstractDictValue",var"##AbstractNamedTupleValue",TensorProto}}}
end
PB.oneof_field_types(::Type{StructuredValue}) = (;
    kind = (;none_value=NoneValue, float64_value=Float64, int64_value=Int64, string_value=String, bool_value=Bool, tensor_shape_value=TensorShapeProto, tensor_dtype_value=var"#DataType".T, tensor_spec_value=TensorSpecProto, type_spec_value=TypeSpecProto, bounded_tensor_spec_value=BoundedTensorSpecProto, list_value=ListValue, tuple_value=TupleValue, dict_value=DictValue, named_tuple_value=NamedTupleValue, tensor_value=TensorProto),
)
PB.default_values(::Type{StructuredValue}) = (;none_value = nothing, float64_value = zero(Float64), int64_value = zero(Int64), string_value = "", bool_value = false, tensor_shape_value = nothing, tensor_dtype_value = var"#DataType".DT_INVALID, tensor_spec_value = nothing, type_spec_value = nothing, bounded_tensor_spec_value = nothing, list_value = nothing, tuple_value = nothing, dict_value = nothing, named_tuple_value = nothing, tensor_value = nothing)
PB.field_numbers(::Type{StructuredValue}) = (;none_value = 1, float64_value = 11, int64_value = 12, string_value = 13, bool_value = 14, tensor_shape_value = 31, tensor_dtype_value = 32, tensor_spec_value = 33, type_spec_value = 34, bounded_tensor_spec_value = 35, list_value = 51, tuple_value = 52, dict_value = 53, named_tuple_value = 54, tensor_value = 55)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:StructuredValue})
    kind = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            kind = OneOf(:none_value, PB.decode(d, Ref{NoneValue}))
        elseif field_number == 11
            kind = OneOf(:float64_value, PB.decode(d, Float64))
        elseif field_number == 12
            kind = OneOf(:int64_value, PB.decode(d, Int64, Val{:zigzag}))
        elseif field_number == 13
            kind = OneOf(:string_value, PB.decode(d, String))
        elseif field_number == 14
            kind = OneOf(:bool_value, PB.decode(d, Bool))
        elseif field_number == 31
            kind = OneOf(:tensor_shape_value, PB.decode(d, Ref{TensorShapeProto}))
        elseif field_number == 32
            kind = OneOf(:tensor_dtype_value, PB.decode(d, var"#DataType".T))
        elseif field_number == 33
            kind = OneOf(:tensor_spec_value, PB.decode(d, Ref{TensorSpecProto}))
        elseif field_number == 34
            kind = OneOf(:type_spec_value, PB.decode(d, Ref{TypeSpecProto}))
        elseif field_number == 35
            kind = OneOf(:bounded_tensor_spec_value, PB.decode(d, Ref{BoundedTensorSpecProto}))
        elseif field_number == 51
            kind = OneOf(:list_value, PB.decode(d, Ref{ListValue}))
        elseif field_number == 52
            kind = OneOf(:tuple_value, PB.decode(d, Ref{TupleValue}))
        elseif field_number == 53
            kind = OneOf(:dict_value, PB.decode(d, Ref{DictValue}))
        elseif field_number == 54
            kind = OneOf(:named_tuple_value, PB.decode(d, Ref{NamedTupleValue}))
        elseif field_number == 55
            kind = OneOf(:tensor_value, PB.decode(d, Ref{TensorProto}))
        else
            PB.skip(d, wire_type)
        end
    end
    return StructuredValue(kind)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::StructuredValue)
    initpos = position(e.io)
    if isnothing(x.kind);
    elseif x.kind.name === :none_value
        PB.encode(e, 1, x.kind[]::NoneValue)
    elseif x.kind.name === :float64_value
        PB.encode(e, 11, x.kind[]::Float64)
    elseif x.kind.name === :int64_value
        PB.encode(e, 12, x.kind[]::Int64, Val{:zigzag})
    elseif x.kind.name === :string_value
        PB.encode(e, 13, x.kind[]::String)
    elseif x.kind.name === :bool_value
        PB.encode(e, 14, x.kind[]::Bool)
    elseif x.kind.name === :tensor_shape_value
        PB.encode(e, 31, x.kind[]::TensorShapeProto)
    elseif x.kind.name === :tensor_dtype_value
        PB.encode(e, 32, x.kind[]::var"#DataType".T)
    elseif x.kind.name === :tensor_spec_value
        PB.encode(e, 33, x.kind[]::TensorSpecProto)
    elseif x.kind.name === :type_spec_value
        PB.encode(e, 34, x.kind[]::TypeSpecProto)
    elseif x.kind.name === :bounded_tensor_spec_value
        PB.encode(e, 35, x.kind[]::BoundedTensorSpecProto)
    elseif x.kind.name === :list_value
        PB.encode(e, 51, x.kind[]::ListValue)
    elseif x.kind.name === :tuple_value
        PB.encode(e, 52, x.kind[]::TupleValue)
    elseif x.kind.name === :dict_value
        PB.encode(e, 53, x.kind[]::DictValue)
    elseif x.kind.name === :named_tuple_value
        PB.encode(e, 54, x.kind[]::NamedTupleValue)
    elseif x.kind.name === :tensor_value
        PB.encode(e, 55, x.kind[]::TensorProto)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::StructuredValue)
    encoded_size = 0
    if isnothing(x.kind);
    elseif x.kind.name === :none_value
        encoded_size += PB._encoded_size(x.kind[]::NoneValue, 1)
    elseif x.kind.name === :float64_value
        encoded_size += PB._encoded_size(x.kind[]::Float64, 11)
    elseif x.kind.name === :int64_value
        encoded_size += PB._encoded_size(x.kind[]::Int64, 12, Val{:zigzag})
    elseif x.kind.name === :string_value
        encoded_size += PB._encoded_size(x.kind[]::String, 13)
    elseif x.kind.name === :bool_value
        encoded_size += PB._encoded_size(x.kind[]::Bool, 14)
    elseif x.kind.name === :tensor_shape_value
        encoded_size += PB._encoded_size(x.kind[]::TensorShapeProto, 31)
    elseif x.kind.name === :tensor_dtype_value
        encoded_size += PB._encoded_size(x.kind[]::var"#DataType".T, 32)
    elseif x.kind.name === :tensor_spec_value
        encoded_size += PB._encoded_size(x.kind[]::TensorSpecProto, 33)
    elseif x.kind.name === :type_spec_value
        encoded_size += PB._encoded_size(x.kind[]::TypeSpecProto, 34)
    elseif x.kind.name === :bounded_tensor_spec_value
        encoded_size += PB._encoded_size(x.kind[]::BoundedTensorSpecProto, 35)
    elseif x.kind.name === :list_value
        encoded_size += PB._encoded_size(x.kind[]::ListValue, 51)
    elseif x.kind.name === :tuple_value
        encoded_size += PB._encoded_size(x.kind[]::TupleValue, 52)
    elseif x.kind.name === :dict_value
        encoded_size += PB._encoded_size(x.kind[]::DictValue, 53)
    elseif x.kind.name === :named_tuple_value
        encoded_size += PB._encoded_size(x.kind[]::NamedTupleValue, 54)
    elseif x.kind.name === :tensor_value
        encoded_size += PB._encoded_size(x.kind[]::TensorProto, 55)
    end
    return encoded_size
end

struct TupleValue <: var"##AbstractTupleValue"
    values::Vector{<:StructuredValue}
end
PB.default_values(::Type{TupleValue}) = (;values = Vector{StructuredValue}())
PB.field_numbers(::Type{TupleValue}) = (;values = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TupleValue})
    values = PB.BufferedVector{StructuredValue}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, values)
        else
            PB.skip(d, wire_type)
        end
    end
    return TupleValue(values[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TupleValue)
    initpos = position(e.io)
    !isempty(x.values) && PB.encode(e, 1, x.values)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TupleValue)
    encoded_size = 0
    !isempty(x.values) && (encoded_size += PB._encoded_size(x.values, 1))
    return encoded_size
end