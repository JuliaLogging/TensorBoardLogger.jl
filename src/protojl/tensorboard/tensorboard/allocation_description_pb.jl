# Autogenerated using ProtoBuf.jl v1.0.11 on 2023-06-19T18:18:24.163
# original file: /home/lior/TensorBoardLogger.jl/gen/proto/tensorboard/compat/proto/allocation_description.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export AllocationDescription

struct AllocationDescription
    requested_bytes::Int64
    allocated_bytes::Int64
    allocator_name::String
    allocation_id::Int64
    has_single_reference::Bool
    ptr::UInt64
end
PB.default_values(::Type{AllocationDescription}) = (;requested_bytes = zero(Int64), allocated_bytes = zero(Int64), allocator_name = "", allocation_id = zero(Int64), has_single_reference = false, ptr = zero(UInt64))
PB.field_numbers(::Type{AllocationDescription}) = (;requested_bytes = 1, allocated_bytes = 2, allocator_name = 3, allocation_id = 4, has_single_reference = 5, ptr = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:AllocationDescription})
    requested_bytes = zero(Int64)
    allocated_bytes = zero(Int64)
    allocator_name = ""
    allocation_id = zero(Int64)
    has_single_reference = false
    ptr = zero(UInt64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            requested_bytes = PB.decode(d, Int64)
        elseif field_number == 2
            allocated_bytes = PB.decode(d, Int64)
        elseif field_number == 3
            allocator_name = PB.decode(d, String)
        elseif field_number == 4
            allocation_id = PB.decode(d, Int64)
        elseif field_number == 5
            has_single_reference = PB.decode(d, Bool)
        elseif field_number == 6
            ptr = PB.decode(d, UInt64)
        else
            PB.skip(d, wire_type)
        end
    end
    return AllocationDescription(requested_bytes, allocated_bytes, allocator_name, allocation_id, has_single_reference, ptr)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::AllocationDescription)
    initpos = position(e.io)
    x.requested_bytes != zero(Int64) && PB.encode(e, 1, x.requested_bytes)
    x.allocated_bytes != zero(Int64) && PB.encode(e, 2, x.allocated_bytes)
    !isempty(x.allocator_name) && PB.encode(e, 3, x.allocator_name)
    x.allocation_id != zero(Int64) && PB.encode(e, 4, x.allocation_id)
    x.has_single_reference != false && PB.encode(e, 5, x.has_single_reference)
    x.ptr != zero(UInt64) && PB.encode(e, 6, x.ptr)
    return position(e.io) - initpos
end
function PB._encoded_size(x::AllocationDescription)
    encoded_size = 0
    x.requested_bytes != zero(Int64) && (encoded_size += PB._encoded_size(x.requested_bytes, 1))
    x.allocated_bytes != zero(Int64) && (encoded_size += PB._encoded_size(x.allocated_bytes, 2))
    !isempty(x.allocator_name) && (encoded_size += PB._encoded_size(x.allocator_name, 3))
    x.allocation_id != zero(Int64) && (encoded_size += PB._encoded_size(x.allocation_id, 4))
    x.has_single_reference != false && (encoded_size += PB._encoded_size(x.has_single_reference, 5))
    x.ptr != zero(UInt64) && (encoded_size += PB._encoded_size(x.ptr, 6))
    return encoded_size
end
