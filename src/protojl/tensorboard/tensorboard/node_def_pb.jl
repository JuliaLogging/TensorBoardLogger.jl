# Autogenerated using ProtoBuf.jl v1.0.11 on 2023-08-08T14:34:18.324
# original path: protojl/tensorboard/tensorboard/node_def.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export var"NodeDef.ExperimentalDebugInfo", NodeDef

struct var"NodeDef.ExperimentalDebugInfo"
    original_node_names::Vector{String}
    original_func_names::Vector{String}
end
PB.default_values(::Type{var"NodeDef.ExperimentalDebugInfo"}) = (;original_node_names = Vector{String}(), original_func_names = Vector{String}())
PB.field_numbers(::Type{var"NodeDef.ExperimentalDebugInfo"}) = (;original_node_names = 1, original_func_names = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"NodeDef.ExperimentalDebugInfo"})
    original_node_names = PB.BufferedVector{String}()
    original_func_names = PB.BufferedVector{String}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, original_node_names)
        elseif field_number == 2
            PB.decode!(d, original_func_names)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"NodeDef.ExperimentalDebugInfo"(original_node_names[], original_func_names[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"NodeDef.ExperimentalDebugInfo")
    initpos = position(e.io)
    !isempty(x.original_node_names) && PB.encode(e, 1, x.original_node_names)
    !isempty(x.original_func_names) && PB.encode(e, 2, x.original_func_names)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"NodeDef.ExperimentalDebugInfo")
    encoded_size = 0
    !isempty(x.original_node_names) && (encoded_size += PB._encoded_size(x.original_node_names, 1))
    !isempty(x.original_func_names) && (encoded_size += PB._encoded_size(x.original_func_names, 2))
    return encoded_size
end

struct NodeDef
    name::String
    op::String
    input::Vector{String}
    device::String
    attr::Dict{String,AttrValue}
    experimental_debug_info::Union{Nothing,var"NodeDef.ExperimentalDebugInfo"}
    experimental_type::Union{Nothing,FullTypeDef}
end
PB.default_values(::Type{NodeDef}) = (;name = "", op = "", input = Vector{String}(), device = "", attr = Dict{String,AttrValue}(), experimental_debug_info = nothing, experimental_type = nothing)
PB.field_numbers(::Type{NodeDef}) = (;name = 1, op = 2, input = 3, device = 4, attr = 5, experimental_debug_info = 6, experimental_type = 7)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:NodeDef})
    name = ""
    op = ""
    input = PB.BufferedVector{String}()
    device = ""
    attr = Dict{String,AttrValue}()
    experimental_debug_info = Ref{Union{Nothing,var"NodeDef.ExperimentalDebugInfo"}}(nothing)
    experimental_type = Ref{Union{Nothing,FullTypeDef}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            op = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, input)
        elseif field_number == 4
            device = PB.decode(d, String)
        elseif field_number == 5
            PB.decode!(d, attr)
        elseif field_number == 6
            PB.decode!(d, experimental_debug_info)
        elseif field_number == 7
            PB.decode!(d, experimental_type)
        else
            PB.skip(d, wire_type)
        end
    end
    return NodeDef(name, op, input[], device, attr, experimental_debug_info[], experimental_type[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::NodeDef)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.op) && PB.encode(e, 2, x.op)
    !isempty(x.input) && PB.encode(e, 3, x.input)
    !isempty(x.device) && PB.encode(e, 4, x.device)
    !isempty(x.attr) && PB.encode(e, 5, x.attr)
    !isnothing(x.experimental_debug_info) && PB.encode(e, 6, x.experimental_debug_info)
    !isnothing(x.experimental_type) && PB.encode(e, 7, x.experimental_type)
    return position(e.io) - initpos
end
function PB._encoded_size(x::NodeDef)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.op) && (encoded_size += PB._encoded_size(x.op, 2))
    !isempty(x.input) && (encoded_size += PB._encoded_size(x.input, 3))
    !isempty(x.device) && (encoded_size += PB._encoded_size(x.device, 4))
    !isempty(x.attr) && (encoded_size += PB._encoded_size(x.attr, 5))
    !isnothing(x.experimental_debug_info) && (encoded_size += PB._encoded_size(x.experimental_debug_info, 6))
    !isnothing(x.experimental_type) && (encoded_size += PB._encoded_size(x.experimental_type, 7))
    return encoded_size
end